package joshua.MERT;
import joshua.decoder.*;
import java.math.*;
import java.util.*;
import java.io.*;
import java.text.DecimalFormat;

public class MERT
{
  private DecimalFormat f0 = new DecimalFormat("###0");
  private DecimalFormat f4 = new DecimalFormat("###0.0000");
  private final Runtime myRuntime = Runtime.getRuntime();

  private final double NegInf = (-1.0 / 0.0);
  private final double PosInf = (+1.0 / 0.0);
  private final double epsilon = 1.0 / 1000000;

  private int progress;

  private int verbosity; // anything of priority <= verbosity will be printed
                         // (lower value for priority means more important)

  private Random randGen;


  private int numSentences;
    // number of sentences in the dev set
    // (aka the "MERT training" set)

  private int refsPerSen;
    // number of reference translations per sentence

  private SentenceInfo[][] refSentenceInfo;
    // sentence information for the reference translations
    // refSentenceInfo[i][r] stores the information for the rth reference
    // translation of the ith sentence

  private int numParams;
    // number of parameters for the log-linear model

  /* *********************************************************** */
  /*   NOTE: indexing starts at 1 in the following few arrays:   */
  /* *********************************************************** */

  private String[] paramNames;
    // parameter names, needed to read/create config file

  private double[] lambda;
    // the current parameter values. NOTE: indexing starts at 1.

  private boolean[] isOptimizable;
    // isOptimizable[c] = true iff lambda[c] should be optimized

  private double[] minValue;
  private double[] maxValue;
    // when optimizing lambda[c], only values in [minValue,maxValue] will be
    // considered.

    // (*) minValue and maxValue can be real values as well as -Infinity and +Infinity
    //     (coded as -Inf and +Inf, respectively, in an input file)

  private double[] defaultLambda;
    // "default" parameter values; simply the values read in the parameter file

  /* *********************************************************** */
  /* *********************************************************** */

  private JoshuaDecoder myDecoder;
    // COMMENT OUT if decoder is not Joshua

  private String decoderCommand;
    // the command that runs the decoder; read from decoderCommandFileName

  private int decVerbosity;
    // verbosity level for decoder output.  If 0, decoder output is ignored.
    // If 1, decoder output is printed.

  private int validDecoderExitValue;
    // return value from running the decoder command that indicates success

  private boolean saveInterFiles;
    // if true, intermediate config files are saved.  If false, they are not.

  private int sizeOfNBest;
    // size of N-best list generated by decoder at each iteration
    // (aka simply N, but N is a bad variable name)

  private long seed;
    // seed used to create random number generators

  private boolean randInit;
    // if true, parameters are initialized randomly.  If false, parameters
    // are initialized using values from parameter file.

  private int initsPerIt;
    // number of intermediate initial points per iteration

  private int maxMERTIterations;
    // maximum number of MERT iterations

  private boolean oneModificationPerIteration;
    // if true, each MERT iteration performs at most one parameter modification.
    // If false, a new MERT iteration starts (i.e. a new N-best list is
    // generated) only after the previous iteration reaches a local maximum.

  private String metricName;
    // name of evaluation metric optimized by MERT

  private EvaluationMetric evalMetric;
    // the evaluation metric used by MERT

  private int suffStatsCount;
    // number of sufficient statistics for the evaluation metric

  private String dirPrefix; // where are all these files located?
  private String paramsFileName, finalLambdaFileName;
  private String sourceFileName, refFileName, decoderOutFileName;
  private String decoderConfigFileName, decoderCommandFileName;
//  private int useDisk;

  public MERT(String[] args) throws Exception
  {
    EvaluationMetric.set_knownNames();
    processArgsArray(args);
    initialize();
  }

  public MERT(String configFileName) throws Exception
  {
    EvaluationMetric.set_knownNames();
    processArgsArray(cfgFileToArgsArray(configFileName));
    initialize();
  }

  private void initialize() throws Exception
  {
    println("----------------------------------------------------",1);
    println("Initializing...",1);
    println("----------------------------------------------------",1);
    println("",1);

    println("Random number generator seed: " + seed,1);
    println("",1);
    randGen = new Random(seed);

    numParams = countLines(paramsFileName);
    numSentences = countLines(sourceFileName);

    if (numSentences * refsPerSen != countLines(refFileName)) {
      println("Line count mismatch between " + sourceFileName + " and " + refFileName);
      System.exit(20);
    }
    // do we really need the source sentences ????????????????????????????????????????
    // well, we need the file containing them, so that the decoder would know
    // what to translate.  But the sentences themselves are not needed for MERT.  Are we
    // storing them anywhere?

    // create copy of config file
    copyFile(decoderConfigFileName,decoderConfigFileName+".orig.MERT");



    paramNames = new String[1+numParams];
    lambda = new double[1+numParams]; // indexing starts at 1 in these arrays
    isOptimizable = new boolean[1+numParams];
    minValue = new double[1+numParams];
    maxValue = new double[1+numParams];
//    precision = new double[1+numParams];
    defaultLambda = new double[1+numParams];

    // read paramter names
    BufferedReader inFile_names = new BufferedReader(new FileReader(paramsFileName));

    for (int c = 1; c <= numParams; ++c) {
      String line = inFile_names.readLine();
      paramNames[c] = (line.substring(0,line.indexOf("|||"))).trim();
    }

    inFile_names.close();


    // initialize lambda[]
    Scanner inFile_init = new Scanner(new FileReader(paramsFileName));

    String dummy = "";

    for (int c = 1; c <= numParams; ++c) {
      while (!dummy.equals("|||")) { dummy = inFile_init.next(); }

      lambda[c] = inFile_init.nextDouble();
      defaultLambda[c] = lambda[c];

      dummy = inFile_init.next();
      if (dummy.equals("Opt")) { isOptimizable[c] = true; }
      else if (dummy.equals("Fix")) { isOptimizable[c] = false; }
      else { println("Unknown isOptimizable string " + dummy + " (must be either Opt or Fix)"); System.exit(21); }

      dummy = inFile_init.next();
      if (dummy.equals("-Inf")) { minValue[c] = NegInf; }
      else if (dummy.equals("+Inf")) { minValue[c] = PosInf; } // who'd ever do that!?
      else { minValue[c] = Double.parseDouble(dummy); }

      dummy = inFile_init.next();
      if (dummy.equals("-Inf")) { maxValue[c] = NegInf; } // who'd ever do that!?
      else if (dummy.equals("+Inf")) { maxValue[c] = PosInf; }
      else { maxValue[c] = Double.parseDouble(dummy); }

      if (minValue[c] == maxValue[c] && isOptimizable[c]) {
        println("Warning: lambda[" + c + "] is optimizable but has minValue = maxValue = " + minValue[c] + ".",1);
        println("         This makes it a fixed parameter at " + minValue[c] + ".",1);
        isOptimizable[c] = false;
        lambda[c] = minValue[c];
      } else if (minValue[c] > maxValue[c]) {
        println("minValue[" + c + "]=" + minValue[c] + " > " + maxValue[c] + "=maxValue[" + c + "]!");
        System.exit(21);
      }
/*
      precision[c] = inFile_init.nextDouble();
      if (precision[c] < 0) {
        println("precision[" + c + "]=" + precision[c] + " < 0!  Must be non-negative.");
        System.exit(21);
      }
*/
      if (!(minValue[c] <= lambda[c] && lambda[c] <= maxValue[c]) && isOptimizable[c]) {
        println("Warning: lambda[" + c + "] is optimizable but has initial value (" + lambda[c] + ")",1);
        println("         that is outside its specified interval [" + minValue[c] + "," + maxValue[c] + "]",1);
      }

    }

    inFile_init.close();


//    SentenceInfo.setNumParams(numParams);
//    SentenceInfo.createV(); // uncomment ONLY IF using vocabulary implementation of SentenceInfo


    refSentenceInfo = new SentenceInfo[numSentences][refsPerSen];

    // read in reference sentences

    BufferedReader inFile_refs = new BufferedReader(new FileReader(refFileName));
    String line;

    for (int i = 0; i < numSentences; ++i) {
      for (int r = 0; r < refsPerSen; ++r) {
        // read the rth reference translation for the ith sentence
        line = inFile_refs.readLine();
        refSentenceInfo[i][r] = new SentenceInfo(line);
      }
    }

    inFile_refs.close();


    // read in decoder command, if any
    if (decoderCommandFileName != null) {
      BufferedReader inFile_comm = new BufferedReader(new FileReader(decoderCommandFileName));
      decoderCommand = inFile_comm.readLine();
      inFile_comm.close();
    } else {
      decoderCommand = null;
    }

    // set static data members for the EvaluationMetric class
    EvaluationMetric.set_numSentences(numSentences);
    EvaluationMetric.set_refsPerSen(refsPerSen);
    EvaluationMetric.set_refSentenceInfo(refSentenceInfo);

    // do necessary initialization for the evaluation metric
    if (metricName.equals("BLEU")) {
      evalMetric = new BLEU(4,"closest");
    } else if (metricName.equals("01LOSS")) {
      evalMetric = new ZeroOneLoss();
    }

    suffStatsCount = evalMetric.get_suffStatsCount();

    println("numSentences = " + numSentences,1);
    println("numParams = " + numParams,1);
    print("  {",1);
    for (int c = 1; c <= numParams; ++c) {
      print("\"" + paramNames[c] + "\"",1);
      if (c < numParams) print(",",1);
    }
    println("}",1);
    println("",1);

    println("c    initial\toptimizable?    range",1);

    for (int c = 1; c <= numParams; ++c) {
      print(c + "    " + f4.format(lambda[c]) + "\t",1);
      if (isOptimizable[c]) print("   Yes          ",1);
      else print("   No           ",1);
//      print("[" + minValue[c] + "," + maxValue[c] + "] @ " + precision[c] + " precision",1);
      print("[" + minValue[c] + "," + maxValue[c] + "]",1);
      println("",1);
    }

    println("",1);

    println("----------------------------------------------------",1);
    println("",1);


    if (decoderCommand == null) {
      myDecoder = new JoshuaDecoder();
      println("Loading Joshua decoder...",1);
      myDecoder.initializeDecoder(decoderConfigFileName);
      println("...finished loading @ " + (new Date()),1);
    }

  } // void initialize(...)


  public void run_MERT() throws Exception
  {
    run_MERT(maxMERTIterations);
  }

  public void run_MERT(int maxIts) throws Exception
  {
    println("----------------------------------------------------",1);
    println("MERT run started @ " + (new Date()),1);
    printMemoryUsage();
    println("----------------------------------------------------",1);
    println("",1);

    if (randInit) {
      println("Initializing lambda[] randomly.",1);

      // initialize optimizable parameters randomly (sampling uniformly from that parameter's range)
      lambda = randomLambda();
    }

    println("Initial lambda[]: " + lambdaToString(lambda),1);
    println("",1);

    int totalCandidateCount = 0;
      // total number of candidates stored in candidates[]

    double FINAL_score = evalMetric.worstPossibleScore();

    for (int iteration = 1; ; ++iteration) {

      println("--- Starting MERT iteration #" + iteration + " @ " + (new Date()) + " ---",1);
/*
      printMemoryUsage();
      for (int i = 0; i < numSentences; ++i) {
        candidates[i].clear();
        lastUsedIndex[i] = -1;
      }
      totalCandidateCount = 0;
      cleanupMemory();
*/
      printMemoryUsage();

      // run the decoder on all the sentences, producing for each sentence a set of
      // sizeOfNBest candidates, with numParams feature values for each candidate

      /******************************/
      // CREATE DECODER CONFIG FILE //
      /******************************/

      createConfigFile(lambda,decoderConfigFileName,decoderConfigFileName+".orig.MERT");

      if (saveInterFiles) {
        // create config file with current values
        createConfigFile(lambda, decoderConfigFileName+".it"+iteration,decoderConfigFileName+".orig.MERT");
      }

      /***************/
      // RUN DECODER //
      /***************/

      if (iteration == 1) {
        println("Decoding using initial weight vector " + lambdaToString(lambda),1);
      } else {
        println("Redecoding using weight vector " + lambdaToString(lambda),1);
      }

      run_decoder();
//run_fake_decoder(sizeOfNBest,iteration); // use only with ex2_ipi20opi0seed1226091488390

      println("...finished decoding @ " + (new Date()),1);

      checkFile(decoderOutFileName);

      if (saveInterFiles) {
        // create copy of current decoder output
        copyFile(decoderOutFileName,decoderOutFileName+".it"+iteration);
      }

      println("Producing temp files for iteration "+iteration,3);

      produceTempFiles(iteration);



      Vector[] candidates = new Vector[numSentences];
        // candidates[i] stores the translation candidates for the ith sentence
        // each element in the array is a Vector of SentenceInfo objects
      double[][][] featVal_array = new double[1+numParams][numSentences][sizeOfNBest];
      featVal_array[0] = null;
      int[] lastUsedIndex = new int[numSentences];
      int[] maxIndex = new int[numSentences];
        // used to grow featVal_array dynamically
      TreeMap[] suffStats_array = new TreeMap[numSentences];
        // suffStats_array[i] maps candidates of interest for sentence i to an array
        // storing the sufficient statistics for that candidate

      for (int i = 0; i < numSentences; ++i) {
        candidates[i] = new Vector(); // a Vector of SentenceInfo's
        lastUsedIndex[i] = -1;
        maxIndex[i] = sizeOfNBest - 1;
        suffStats_array[i] = new TreeMap();
      }

      double[][] initialLambda = new double[1+initsPerIt][1+numParams]; // the intermediate "initial" lambdas
      double[][] finalLambda = new double[1+initsPerIt][1+numParams]; // the intermediate "final" lambdas

      // set initialLambda[][]
      System.arraycopy(lambda,1,initialLambda[1],1,numParams);
      for (int j = 2; j <= initsPerIt; ++j) { initialLambda[j] = randomLambda(); }

      double[] initialScore = new double[1+initsPerIt];
      double[] finalScore = new double[1+initsPerIt];

      SentenceInfo[][] best1Cand = new SentenceInfo[1+initsPerIt][numSentences];
        // used to calculate initialScore[]
      String[][] best1Cand_sen = new String[1+initsPerIt][numSentences];
      double[][] best1Score = new double[1+initsPerIt][numSentences];


      println("Reading candidate translations.",2);
      progress = 0;

      boolean newCandidatesAdded = false;


      // each inFile corresponds to the output of an iteration
      BufferedReader[] inFile_sents = new BufferedReader[1+iteration];
      BufferedReader[] inFile_feats = new BufferedReader[1+iteration];
      BufferedReader[] inFile_stats = new BufferedReader[1+iteration];
      for (int it = 1; it <= iteration; ++it) {
        inFile_sents[it] = new BufferedReader(new FileReader(decoderOutFileName+".temp.sents.it"+it));
        inFile_feats[it] = new BufferedReader(new FileReader(decoderOutFileName+".temp.feats.it"+it));
        inFile_stats[it] = new BufferedReader(new FileReader(decoderOutFileName+".temp.stats.it"+it));
      }

      // to be used to write sentences from all the output files into a single one
/*
      FileOutputStream outStream_sents = new FileOutputStream(decoderOutFileName+".temp.sents.merged", false); // false: don't append
      OutputStreamWriter outStreamWriter_sents = new OutputStreamWriter(outStream_sents, "utf8");
      BufferedWriter outFile_sents = new BufferedWriter(outStreamWriter_sents);
*/
      // to be used to write sufficient statistics from all the sentences from the output files into a single one
      PrintWriter outFile_stats = new PrintWriter(decoderOutFileName+"temp.stats.merged");

//      String orig_line, line, candidate_str;
      String sents_str, feats_str, stats_str;

      for (int i = 0; i < numSentences; ++i) {

        HashSet<String> existingCandidates = new HashSet<String>();

        for (int j = 1; j <= initsPerIt; ++j) {
          best1Cand[j][i] = null;
          best1Cand_sen[j][i] = null;
          best1Score[j][i] = NegInf;
        }

        for (short it = 1; it <= iteration; ++it) {

          for (short n = 0; n < sizeOfNBest; ++n) {

            // for the nth candidate for the ith sentence, read the sentence, feature values,
            // and sufficient statistics from the various temp files

            sents_str = inFile_sents[it].readLine();
            feats_str = inFile_feats[it].readLine();
            stats_str = inFile_stats[it].readLine();

            if (!existingCandidates.contains(sents_str)) {

              outFile_stats.println(stats_str);

              String[] featVal_str = feats_str.split("\\s+");

              double[] featVal = new double[1+numParams];

              for (int c = 1; c <= numParams; ++c) {
                featVal[c] = Double.parseDouble(featVal_str[c-1]);
//                print("fV[" + c + "]=" + featVal[c] + " ",3);
              }
//              println("",3);


              for (int j = 1; j <= initsPerIt; ++j) {
                double score = 0;
                for (int c = 1; c <= numParams; ++c) {
                  score += initialLambda[j][c] * featVal[c];
                }
                if (score > best1Score[j][i]) {
                  best1Score[j][i] = score;
                  best1Cand_sen[j][i] = sents_str;
                }
              }

              existingCandidates.add(sents_str);

              SentenceInfo candidate = new SentenceInfo();

              setFeats(featVal_array,i,lastUsedIndex,maxIndex,featVal);
//              candidate.setLocationInfo(it,n);
              candidates[i].add(candidate);
              ++totalCandidateCount;
              if (it == iteration) {
                newCandidatesAdded = true;
              }

            }

            showProgress();

          } // for (n)

          existingCandidates.clear();

        } // for (it)

      } // for (i)

      for (int i = 0; i < numSentences; ++i) {
        for (int j = 1; j <= initsPerIt; ++j) {
          best1Cand[j][i] = new SentenceInfo(best1Cand_sen[j][i]);
          best1Cand_sen[j][i] = null;
        }
      }

      for (int it = 1; it <= iteration; ++it) {
        inFile_sents[it].close();
        inFile_feats[it].close();
        inFile_stats[it].close();
      }

      outFile_stats.close();

      println("",2); // to finish off progress dot line

//      cleanupMemory();

      println("",1);

      if (!newCandidatesAdded) {
        if (!oneModificationPerIteration) {
          println("No new candidates added in this iteration; exiting MERT.",1);
          println("",1);
          println("---  MERT iteration #" + iteration + " ending @ " + (new Date()) + "  ---",1);
          println("",1);
          break; // exit for (iteration) loop
        } else {
          println("Note: No new candidates added in this iteration.",1);
        }
      }


      for (int j = 1; j <= initsPerIt; ++j) {

        println("+++ Optimization of lambda[j=" + j + "] starting @ " + (new Date()) + " +++",1);

        double[] currLambda = new double[1+numParams];
        System.arraycopy(initialLambda[j],1,currLambda,1,numParams);
        initialScore[j] = evalMetric.score(best1Cand[j]);
        println("Initial lambda[j=" + j + "]: " + lambdaToString(initialLambda[j]),1);
        println("(Initial score[j=" + j + "]: " + initialScore[j] + ")",1);
        println("",1);
        finalScore[j] = initialScore[j];

        while (true) {

          double[] c_best_info = bestParamToChange(j,currLambda,candidates,featVal_array,suffStats_array,(short)1,(short)iteration);

          int c_best = (int)c_best_info[0]; // which param to change?
          double bestLambdaVal = c_best_info[1]; // what value to change to?
          double bestScore = c_best_info[2]; // what score would be achieved?

          // now c_best is the parameter giving the most gain

          if (evalMetric.isBetter(bestScore,finalScore[j])) {
            println("*** Changing lambda[j=" + j + "][" + c_best + "] from " + f4.format(currLambda[c_best]) + " (score: " + f4.format(finalScore[j]) + ") to " + f4.format(bestLambdaVal) + " (score: " + f4.format(bestScore) + ") ***",2);
            println("*** Old lambda[j=" + j + "]: " + lambdaToString(currLambda) + " ***",2);
            currLambda[c_best] = bestLambdaVal;
            finalScore[j] = bestScore;
            println("*** New lambda[j=" + j + "]: " + lambdaToString(currLambda) + " ***",2);
            println("",2);
          } else {
            println("*** Not changing any weight in lambda[j=" + j + "] ***",2);
            println("*** Final lambda[j=" + j + "]: " + lambdaToString(currLambda) + " ***",2);
            println("",2);
            break; // exit while (true) loop
          }

          if (oneModificationPerIteration) { break; } // exit while (true) loop

        } // while (true)

        // now currLambda is the optimized weight vector on the current candidate list (corresponding to initialLambda[j])

        System.arraycopy(currLambda,1,finalLambda[j],1,numParams);
        println("Final lambda[j=" + j + "]: " + lambdaToString(finalLambda[j]),1);
        println("(Final score[j=" + j + "]: " + finalScore[j] + ")",1);
        println("",1);

      } // for (j)


      int best_j = 1;
      double bestFinalScore = finalScore[1];
      for (int j = 2; j <= initsPerIt; ++j) {
        if (evalMetric.isBetter(finalScore[j],bestFinalScore)) {
          best_j = j;
          bestFinalScore = finalScore[j];
        }
      }

      if (initsPerIt > 1) {
        println("Best final lambda is lambda[j=" + best_j + "] (score: " + f4.format(bestFinalScore) + ").",1);
        println("",1);
      }

      FINAL_score = bestFinalScore;

      boolean anyParamChanged = false;

      for (int c = 1; c <= numParams; ++c) {
        if (finalLambda[best_j][c] != lambda[c]) {
          anyParamChanged = true;
        }
      }

      if (!anyParamChanged) {
        println("No parameter values changed in this iteration; exiting MERT.",1);
        println("",1);
        println("---  MERT iteration #" + iteration + " ending @ " + (new Date()) + "  ---",1);
        println("",1);
        break; // exit for (iteration) loop preemptively
      }

      System.arraycopy(finalLambda[best_j],1,lambda,1,numParams);



      // if max iteration reached, exit
      if (iteration == maxIts) {
        println("Maximum number of MERT iterations reached; exiting MERT.",1);
        println("",1);
        println("---  MERT iteration #" + iteration + " ending @ " + (new Date()) + "  ---",1);
        println("",1);
        break; // exit for (iteration) loop
      }

      println("Next iteration will decode with lambda: " + lambdaToString(lambda),1);
      println("",1);
      println("---  MERT iteration #" + iteration + " ending @ " + (new Date()) + "  ---",1);
      println("",1);

      printMemoryUsage();
      for (int i = 0; i < numSentences; ++i) { candidates[i].clear(); }
//      cleanupMemory();
      println("",2);

    } // for (iteration)

    println("",1);

    println("----------------------------------------------------",1);
    println("MERT run ended @ " + (new Date()),1);
    printMemoryUsage();
    println("----------------------------------------------------",1);
    println("",1);
    println("FINAL lambda: " + lambdaToString(lambda) + " (score: " + FINAL_score + ")",1);
    println("",1);

    // delete intermediate .temp.*.it* decoder output files
    for (int iteration = 1; iteration <= maxIts; ++iteration) {
      if (fileExists(decoderOutFileName+".temp.sents.it"+iteration)) {
        File cp = new File(decoderOutFileName+".temp.sents.it"+iteration);
        cp.delete();
      }
      if (fileExists(decoderOutFileName+".temp.feats.it"+iteration)) {
        File cp = new File(decoderOutFileName+".temp.feats.it"+iteration);
        cp.delete();
      }
      if (fileExists(decoderOutFileName+".temp.stats.it"+iteration)) {
        File cp = new File(decoderOutFileName+".temp.stats.it"+iteration);
        cp.delete();
      }
    }

    // delete .temp.stats.merged file
/*
    if (fileExists(decoderOutFileName+".temp.sent.merged")) {
      File cp = new File(decoderOutFileName+".temp.sent.merged");
      cp.delete();
    }
*/
    if (fileExists(decoderOutFileName+"temp.stats.merged")) {
      File cp = new File(decoderOutFileName+"temp.stats.merged");
      cp.delete();
    }

  } // void run_MERT(int maxIts)

  private double[] bestParamToChange(int j, double[] currLambda, Vector[] candidates, double[][][] featVal_array, TreeMap[] suffStats_array, short minIt, short maxIt) throws Exception
  {
    int c_best = 0; // which parameter to change?
    double bestLambdaVal = 0.0;
    double bestScore;
    if (evalMetric.getToBeMinimized()) {
      bestScore = evalMetric.worstPossibleScore() + 1.0;
    } else {
      bestScore = evalMetric.worstPossibleScore() - 1.0;
    }




    // prep for line_opt

    TreeSet[] indicesOfInterest = null;
    // indicesOfInterest[i] tells us which candidates for the ith sentence need
    // to be read from the merged decoder output file.

//    if (useDisk == 2) {
      indicesOfInterest = new TreeSet[numSentences];
      for (int i = 0; i < numSentences; ++i) {
        indicesOfInterest[i] = new TreeSet<Integer>();
      }
//    }

    TreeMap[] thresholdsAll = new TreeMap[1+numParams];
    int[][] indexOfCurrBest = new int[1+numParams][numSentences];

    for (int c = 1; c <= numParams; ++c) {
      if (!isOptimizable[c]) {
        println("Not investigating lambda[j=" + j + "][" + c + "].",2);
        thresholdsAll[c] = null;
      } else {
        println("Investigating lambda[j=" + j + "][" + c + "]...",2);
        thresholdsAll[c] = thresholdsForParam(c,candidates,featVal_array,currLambda,indicesOfInterest);
        // now thresholdsAll has the values for lambda_c at which score changes
        // based on the candidates for *all* the sentences (that satisfy
        // range constraints).
        // Each lambda_c value maps to a Vector of th_info.  An overwhelming majority
        // of these Vectors are of size 1.

        if (thresholdsAll[c].size() != 0) {

          double[] temp_lambda = new double[1+numParams];
          System.arraycopy(currLambda,1,temp_lambda,1,numParams);

          double smallest_th = (Double)(thresholdsAll[c].firstKey());

          if (minValue[c] != NegInf) {
            temp_lambda[c] = (minValue[c] + smallest_th) / 2.0;
          } else {
            temp_lambda[c] = smallest_th - 0.05;
          }

          indexOfCurrBest[c] = initial_indexOfCurrBest(c,candidates,featVal_array,temp_lambda,indicesOfInterest);
        }
      }

      println("",2);

    }



/*
    if (useDisk == 2) {
      // process the decoder output files, and read the sentences corresponding to the
      // candidates of interest (use the info in indicesOfInterest to determine them)

      setSentencesOfInterest(indicesOfInterest,candidates);

    } // if (useDisk == 2)
*/


    set_suffStats_array(suffStats_array,indicesOfInterest,candidates);



    for (int c = 1; c <= numParams; ++c) {
    // investigate currLambda[j][c]

      if (isOptimizable[c]) {
        double[] bestScoreInfo_c = line_opt(thresholdsAll[c],indexOfCurrBest[c],c,candidates,featVal_array,suffStats_array,currLambda,minIt,maxIt);
          // get best score and its lambda value

        double bestLambdaVal_c = bestScoreInfo_c[0];
        double bestScore_c = bestScoreInfo_c[1];

        if (evalMetric.isBetter(bestScore_c,bestScore)) {
          c_best = c;
          bestLambdaVal = bestLambdaVal_c;
          bestScore = bestScore_c;
        }

      } // if (!isOptimizable[c])

    }





    // delete according to indicesOfInterest

    printMemoryUsage();

//    if (useDisk == 2) {
      // delete the sentences from the candidates formerly of interest

      for (int i = 0; i < numSentences; ++i) {
/*
        Iterator It2 = indicesOfInterest[i].iterator();
        while (It2.hasNext()) {
          int nextIndex = (Integer)It2.next();
          ((SentenceInfo)candidates[i].elementAt(nextIndex)).deleteSentence();
        }
*/
        indicesOfInterest[i].clear();
      }

//    }

//    cleanupMemory();
    printMemoryUsage();
    println("",2);








    double[] c_best_info = {c_best,bestLambdaVal,bestScore};
    return c_best_info;

  } // double[] bestParamToChange(int j, double[] currLambda)


  private String lambdaToString(double[] lambda)
  {
    String retStr = "{";
    for (int c = 1; c <= numParams-1; ++c) {
      retStr += "" + lambda[c] + ", ";
    }
    retStr += "" + lambda[numParams] + "}";

    return retStr;
  }

  private void run_decoder() throws Exception
  {
    if (decoderCommand == null) {
      println("Running Joshua decoder...",1);
//      myDecoder.initializeDecoder(decoderConfigFileName);
      double[] zeroBased_lambda = new double[numParams];
      System.arraycopy(lambda,1,zeroBased_lambda,0,numParams);
      myDecoder.changeFeatureWeightVector(zeroBased_lambda);
      myDecoder.decodingTestSet(sourceFileName, decoderOutFileName);
    } else {
      println("Running decoder...",1);

      Runtime rt = Runtime.getRuntime();
      Process p = rt.exec(decoderCommand);
      InputStream is = p.getErrorStream();
      InputStreamReader isr = new InputStreamReader(is);
      BufferedReader br = new BufferedReader(isr);
      String dummy_line = null;
      while ((dummy_line = br.readLine()) != null) {
        if (decVerbosity == 1) {
          println(dummy_line);
        }
      }
      int decStatus = p.waitFor();

      if (decStatus != validDecoderExitValue) {
        println("Call to decoder returned " + decStatus + "; was expecting " + validDecoderExitValue + ".");
        System.exit(30);
      }
    }
  }

  private void run_fake_decoder(int N, int iteration) throws Exception
  {
    println("Running fake decoder...",1);
    // use only with ex2_ipi20opi0seed1226091488390
    copyFile(decoderOutFileName+".N"+N+".it"+iteration,decoderOutFileName);
  }

  private double[] line_opt(TreeMap<Double,Vector> thresholdsAll, int[] indexOfCurrBest, int c, Vector[] candidates, double[][][] featVal_array, TreeMap[] suffStats_array, double[] lambda, short minIt, short maxIt) throws Exception
  {
    println("Line-optimizing lambda[" + c + "]...",3);

    double[] bestScoreInfo = new double[2];
      // to be returned: [0] will store the best lambda, and [1] will store its score

    if (thresholdsAll.size() == 0) {
      // no thresholds extracted!  Possible in theory...
      // simply return current value for this parameter
      println("No thresholds extracted!  Returning this parameter's current value...",2);

      bestScoreInfo[0] = lambda[c];
      bestScoreInfo[1] = evalMetric.worstPossibleScore();

      return bestScoreInfo;
    }

    double smallest_th = thresholdsAll.firstKey();
    double largest_th = thresholdsAll.lastKey();
    println("Minimum threshold: " + smallest_th,3);
    println("Maximum threshold: " + largest_th,3);

    double[] temp_lambda = new double[1+numParams];
    System.arraycopy(lambda,1,temp_lambda,1,numParams);

    double ip_prev = 0.0, ip_curr = 0.0;

    if (minValue[c] != NegInf) {
      temp_lambda[c] = (minValue[c] + smallest_th) / 2.0;
      ip_curr = minValue[c];
    } else {
      temp_lambda[c] = smallest_th - 0.05;
      ip_curr = smallest_th - 0.1;
    }




    double[][] suffStats = new double[numSentences][suffStatsCount];
      // suffStats[i][s] stores the contribution to the sth sufficient
      // statistic from the candidate for the ith sentence (the candidate
      // indicated by indexOfCurrBest[i]).

    double[] suffStats_tot = new double[suffStatsCount];
      // suffStats_tot[s] := SUM_i suffStats[i][s]

    for (int s = 0; s < suffStatsCount; ++s) { suffStats_tot[s] = 0; }

    // Now, set suffStats[][], and increment suffStats_tot[]
    for (int i = 0; i < numSentences; ++i) {
//      suffStats[i] = evalMetric.suffStats((SentenceInfo)candidates[i].elementAt(indexOfCurrBest[i]),i);
      suffStats[i] = (double[])suffStats_array[i].get(indexOfCurrBest[i]);

      for (int s = 0; s < suffStatsCount; ++s) {
        suffStats_tot[s] += suffStats[i][s];
      }
    }



    double bestScore = evalMetric.score(suffStats_tot);
    double bestLambdaVal = temp_lambda[c];
    double nextLambdaVal = bestLambdaVal;
    println("At lambda[" + c + "] = " + bestLambdaVal + ",\t" + metricName + " = " + bestScore + " (*)",3);

    Iterator It = (thresholdsAll.keySet()).iterator();
    if (It.hasNext()) { ip_curr = (Double)It.next(); }

    while (It.hasNext()) {
      ip_prev = ip_curr;
      ip_curr = (Double)It.next();
      nextLambdaVal = (ip_prev + ip_curr)/2.0;

      Vector th_info_V = thresholdsAll.get(ip_prev);
      for (int t = 0; t < th_info_V.size(); ++t) {
        int[] th_info = (int[])th_info_V.elementAt(t);
        int i = th_info[0];
        int old_k = th_info[1]; // should be equal to indexOfCurrBest[i]
        int new_k = th_info[2];

        for (int s = 0; s < suffStatsCount; ++s) {
          suffStats_tot[s] -= suffStats[i][s]; // subtract stats for candidate old_k
        }

        indexOfCurrBest[i] = new_k;
//        suffStats[i] = evalMetric.suffStats((SentenceInfo)candidates[i].elementAt(indexOfCurrBest[i]),i);
        suffStats[i] = (double[])suffStats_array[i].get(indexOfCurrBest[i]);

        for (int s = 0; s < suffStatsCount; ++s) {
          suffStats_tot[s] += suffStats[i][s]; // add stats for candidate new_k
        }

      }

      double nextTestScore = evalMetric.score(suffStats_tot);
      print("At lambda[" + c + "] = " + nextLambdaVal + ",\t" + metricName + " = " + nextTestScore,3);

      if (evalMetric.isBetter(nextTestScore,bestScore)) {
        bestScore = nextTestScore;
        bestLambdaVal = nextLambdaVal;
        print(" (*)",3);
      }

      println("",3);

    } // while (It.hasNext())

    println("",3);

    // what is the purpose of this block of code ?????????????????????
/*
    if (maxValue[c] != PosInf) {
      nextLambdaVal = (largest_th + maxValue[c]) / 2.0;
    } else {
      nextLambdaVal = largest_th + 0.05;
    }
*/
    // ???????????????????????????????????????????????????????????????

    /*************************************************/
    /*************************************************/

    bestScoreInfo[0] = bestLambdaVal;
    bestScoreInfo[1] = bestScore;

    return bestScoreInfo;

  } // double[] line_opt(int c)


  private TreeMap<Double,Vector> thresholdsForParam(int c, Vector[] candidates, double[][][] featVal_array, double[] lambda, TreeSet[] indicesOfInterest)
  {
    TreeMap[] thresholds = new TreeMap[numSentences];
      // thresholds[i] stores thresholds for the cth parameter obtained by
      // processing the candidates of sentence i.  It not only stores the
      // thresholds themselves, but also a triple of {i,from,to}, where from/to
      // are indices that characterize the 1-best switch at this threshold.

    for (int i = 0; i < numSentences; ++i) {
      thresholds[i] = new TreeMap();
    }

    // Find threshold points

    int ipCount = 0;
    for (int i = 0; i < numSentences; ++i) {
    // find threshold points contributed by ith sentence

//      println("Processing sentence #" + i,3);

      thresholds[i].clear();

      int numCandidates = candidates[i].size();
        // aka simply K

      double[] slope = new double[numCandidates];
        // will be h_c from candidatesInfo
        // repeated here for easy access
      double[] offset = new double[numCandidates];
        // SUM_j!=c lambda_j*h_j(x)

      int minSlopeIndex = -1;          // index of line with steepest descent...
      double minSlope = PosInf;        // ...and its slope...
      double offset_minSlope = NegInf; // ...and its offset (needed to break ties)

      int maxSlopeIndex = -1;          // index of line with steepest ascent...
      double maxSlope = NegInf;        // ...and its slope...
      double offset_maxSlope = NegInf; // ...and its offset (needed to break ties)

      for (int k = 0; k < numCandidates; ++k) {
//        double[] featVal = getFeats(featVal_array,i,k);

//        slope[k] = featVal[c];
        slope[k] = featVal_array[c][i][k];

        offset[k] = 0.0;
        for (int c2 = 1; c2 <= numParams; ++c2) {
//          if (c2 != c) { offset[k] += lambda[c2]*featVal[c2]; }
          if (c2 != c) { offset[k] += lambda[c2]*featVal_array[c2][i][k]; }
        }

        // debugging
//        println("@ (i,k,n)=(" + i + "," + k + "," + (int)featVal[0] + "), "
//               + "slope = " + slope[k] + "; offset = " + offset[k],3);

        if (slope[k] < minSlope || (slope[k] == minSlope && offset[k] > offset_minSlope)) {
          minSlopeIndex = k;
          minSlope = slope[k];
          offset_minSlope = offset[k];
        }

        if (slope[k] > maxSlope || (slope[k] == maxSlope && offset[k] > offset_maxSlope)) {
          maxSlopeIndex = k;
          maxSlope = slope[k];
          offset_maxSlope = offset[k];
        }
      }

      // PS: now k equals numCandidates-1

      // debugging
      println("minSlope is @ k = " + minSlopeIndex + ": slope " + minSlope + " (offset " + offset_minSlope + ")",3);
      println("maxSlope is @ k = " + maxSlopeIndex + ": slope " + maxSlope + " (offset " + offset_maxSlope + ")",3);


      // some lines can be eliminated: the ones that have a lower offset
      // than some other line with the same slope.
      // That is, for any k1 and k2:
      //   if slope[k1] = slope[k2] and offset[k1] > offset[k2],
      //   then k2 can be eliminated.
      // (This is actually important to do as it eliminates a bug.)
      HashSet<Integer> discardedIndices = indicesToDiscard(slope,offset);


      println("Extracting thresholds[(i,c)=(" + i + "," + c + ")]",3);

      int currIndex = minSlopeIndex;
        // As we traverse the lambda_c dimension, the "winner" candidate will
        // change at intersection points.  currIndex tells us which candidate
        // is the winner in the interval currently under investigation.

        // We traverse the lambda_c dimension starting at -Inf.  The line with
        // steepest descent is the winner as lambda_c -> -Inf, so we initialize
        // currIndex to minSlopeIndex to reflect that fact.

        // Similarly, the winner as lambda_c -> +Inf is the line with the
        // steepest *ascent* (i.e. max slope), and so we continue finding
        // intersection points until we hit that line.

      while (currIndex != maxSlopeIndex) {

        print("cI=" + currIndex + " ",3);

        // find the candidate whose line is the first to intersect the current
        // line.  ("first" meaning with an intersection point that has the
        //         lowest possible lambda_c value.)

        double nearestIntersectionPoint = PosInf;
        int nearestIntersectingLineIndex = -1;

        for (int k = 0; k < numCandidates; ++k) {
          if (slope[k] > slope[currIndex] && !discardedIndices.contains(k)) {
          // only higher-sloped lines will intersect the current line
          // (If we didn't have discardedIndices a bug would creep up here.)

            // find intersection point ip_k
            double ip_k = (offset[k] - offset[currIndex])/(slope[currIndex] - slope[k]);
            if (ip_k < nearestIntersectionPoint) {
              nearestIntersectionPoint = ip_k;
              nearestIntersectingLineIndex = k;
            }
          }
        }

        print("ip=" + f4.format(nearestIntersectionPoint) + " ",3);
        ++ipCount;

        int[] th_info = {i,currIndex,nearestIntersectingLineIndex};

        if (!thresholds[i].containsKey(nearestIntersectionPoint)) {
          thresholds[i].put(nearestIntersectionPoint,th_info);
            // i.e., at lambda_c = nIP, the (index of the) 1-best changes
            // from currIndex to nearestIntersectingLineIndex (which is
            // indicated in th_info)
        } else { // extremely rare, but causes problem if it does occur
          // in essence, just replace the new_k of the existing th_info
          int[] old_th_info = (int[])thresholds[i].get(nearestIntersectionPoint);
          old_th_info[2] = th_info[2];
          thresholds[i].put(nearestIntersectionPoint,old_th_info);
          // When does this happen?  If two consecutive intersection points are so close
          // to each other so as to appear as having the same value.  For instance, assume
          // we have two intersection points ip1 and ip2 corresponding to two transitions,
          // one from k_a to k_b, and the other from k_b to k_c.  It might be the case
          // that ip2-ip1 is extremeley small, so that the ip2 entry would actually REPLACE
          // the ip1 entry.  This would be bad.

          // Instead, we pretend that k_b never happened, and just assume there is a single
          // intersection point, ip (which equals whatever value Java calculates for ip1
          // and ip2), with a corresponding transition of k_a to k_c.
        }

        currIndex = nearestIntersectingLineIndex;

      } // end while (currIndex != maxSlopeIndex)

      println("cI=" + currIndex + "(=? " + maxSlopeIndex + " = mxSI)",3);

      // now thresholds[i] has the values for lambda_c at which score changes
      // based on the candidates for the ith sentence

      println("",3);

    } // for (i)

    TreeMap<Double,Vector> thresholdsAll = new TreeMap<Double,Vector>();
    for (int i = 0; i < numSentences; ++i) {
      Iterator It = (thresholds[i].keySet()).iterator();
      int[] th_info = null;
      while (It.hasNext()) { // process intersection points contributd by this sentence
        double ip = (Double)It.next();
        if (ip > minValue[c] && ip < maxValue[c]) {
          th_info = (int[])(thresholds[i].get(ip));
          if (!thresholdsAll.containsKey(ip)) {
            Vector A = new Vector();
            A.add(th_info);
            thresholdsAll.put(ip,A);
          } else { // though rare, it does happen
            Vector A = thresholdsAll.get(ip);
            A.add(th_info);
            thresholdsAll.put(ip,A);
          }

//          if (useDisk == 2) {
            // th_info[0] = i, th_info[1] = old_k, th_info[2] = new_k
            int old_k = th_info[1];
//            short loc_it = ((SentenceInfo)candidates[i].elementAt(old_k)).getLocationInfo_it();
//            short loc_cand = ((SentenceInfo)candidates[i].elementAt(old_k)).getLocationInfo_cand();

            indicesOfInterest[i].add(old_k);
//          }

        } // if (in-range)

      } // while (It.hasNext())

//      if (useDisk == 2 && th_info != null) {
      if (th_info != null) {
        // new_k from the last th_info (previous new_k already appear as the next old_k)
        int new_k = th_info[2];
//        short loc_it = ((SentenceInfo)candidates[i].elementAt(new_k)).getLocationInfo_it();
//        short loc_cand = ((SentenceInfo)candidates[i].elementAt(new_k)).getLocationInfo_cand();

        indicesOfInterest[i].add(new_k);
      }

    } // for (i)

    // now thresholdsAll has the values for lambda_c at which score changes
    // based on the candidates for *all* the sentences (that satisfy
    // range constraints).
    // Each lambda_c value maps to a Vector of th_info.  An overwhelming majority
    // of these Vectors are of size 1.

    // indicesOfInterest[i] tells us which candidates for the ith sentence need
    // to be read from the merged decoder output file.

    if (thresholdsAll.size() != 0) {
      double smallest_th = thresholdsAll.firstKey();
      double largest_th = thresholdsAll.lastKey();
      println("Smallest extracted threshold: " + smallest_th,2);
      println("Largest extracted threshold: " + largest_th,2);

      if (maxValue[c] != PosInf) {
        thresholdsAll.put(maxValue[c],null);
      } else {
        thresholdsAll.put((thresholdsAll.lastKey() + 0.1),null);
      }
    }

    return thresholdsAll;

  } // TreeMap<Double,Vector> thresholdsForParam (int c)


  private int[] initial_indexOfCurrBest(int c, Vector[] candidates, double[][][] featVal_array, double[] temp_lambda, TreeSet[] indicesOfInterest)
  {
    int[] indexOfCurrBest = new int[numSentences];
      // As we traverse lambda_c, indexOfCurrBest indicates which is the
      // current best candidate.

    // initialize indexOfCurrBest[]

    for (int i = 0; i < numSentences; ++i) {
      int numCandidates = candidates[i].size();

      double max = NegInf;
      int indexOfMax = -1;
      for (int k = 0; k < numCandidates; ++k) {
        double score = 0;
//        double[] featVals = getFeats(featVal_array,i,k);

//        for (int c2 = 1; c2 <= numParams; ++c2) { score += temp_lambda[c2] * featVals[c2]; }
        for (int c2 = 1; c2 <= numParams; ++c2) { score += temp_lambda[c2] * featVal_array[c2][i][k]; }
        if (score > max) {
          max = score;
          indexOfMax = k;
        }
      }

      indexOfCurrBest[i] = indexOfMax;

//      if (useDisk == 2) {
        // add indexOfCurrBest[i] to indicesOfInterest
//        short loc_it = ((SentenceInfo)candidates[i].elementAt(indexOfMax)).getLocationInfo_it();
//        short loc_cand = ((SentenceInfo)candidates[i].elementAt(indexOfMax)).getLocationInfo_cand();
        indicesOfInterest[i].add(indexOfMax);
//      }

    }

    return indexOfCurrBest;

  } // int[] initial_indexOfCurrBest (int c)



  private void produceTempFiles(int iteration) throws Exception
  {
    String sentsFileName = decoderOutFileName+".temp.sents.it"+iteration;
    String featsFileName = decoderOutFileName+".temp.feats.it"+iteration;
    String statsFileName = decoderOutFileName+".temp.stats.it"+iteration;

    FileOutputStream outStream_sents = new FileOutputStream(sentsFileName, false); // false: don't append
    OutputStreamWriter outStreamWriter_sents = new OutputStreamWriter(outStream_sents, "utf8");
    BufferedWriter outFile_sents = new BufferedWriter(outStreamWriter_sents);

    PrintWriter outFile_feats = new PrintWriter(featsFileName);
    PrintWriter outFile_stats = new PrintWriter(statsFileName);



    BufferedReader inFile = new BufferedReader(new FileReader(decoderOutFileName));
    String line; //, prevLine;
    String candidate_str = "";
    String feats_str = "";
    double[] stats = new double[suffStatsCount];

    int i = 0; int n = 0;
    line = inFile.readLine();
//    prevLine = "";

    while (line != null) {

/*
line format:

.* ||| words of candidate translation . ||| feat-1_val feat-2_val ... feat-numParams_val .*

*/

      // in a well formed file, we'd find the nth candidate for the ith sentence

      int read_i = Integer.parseInt(line.substring(0,line.indexOf(" |||")));

      if (read_i != i) { // bad; add dummy copies of last seen candidate
        while (n < sizeOfNBest) {
          writeLine(candidate_str, outFile_sents);
          outFile_feats.println(feats_str);
          for (int s = 0; s < suffStatsCount-1; ++s) { outFile_stats.print(stats[s] + " "); }
          outFile_stats.println(stats[suffStatsCount-1]);
          ++n;
        }
        n = 0; ++i;
      }

      line = line.substring(line.indexOf("||| ")+4); // get rid of initial text

      candidate_str = line.substring(0,line.indexOf(" |||"));
      feats_str = line.substring(line.indexOf("||| ")+4); // get rid of candidate
      feats_str = feats_str.substring(0,feats_str.indexOf(" |||"));
      stats = evalMetric.suffStats((new SentenceInfo(candidate_str)),i);

      writeLine(candidate_str, outFile_sents);
      outFile_feats.println(feats_str);
      for (int s = 0; s < suffStatsCount-1; ++s) { outFile_stats.print(stats[s] + " "); }
      outFile_stats.println(stats[suffStatsCount-1]);

      ++n;
      if (n == sizeOfNBest) { n = 0; ++i; }

//      prevLine = line;
      line = inFile.readLine();
    }

    if (i != numSentences) { // last sentence had too few candidates
      while (n < sizeOfNBest) {
        writeLine(candidate_str, outFile_sents);
        outFile_feats.println(feats_str);
        for (int s = 0; s < suffStatsCount-1; ++s) { outFile_stats.print(stats[s] + " "); }
        outFile_stats.println(stats[suffStatsCount-1]);
        ++n;
      }
    }

    inFile.close();
    outFile_sents.close();
    outFile_feats.close();
    outFile_stats.close();

  }

  private void createConfigFile(double[] params, String cfgFileName, String templateFileName) throws Exception
  {
    // i.e. create cfgFileName, which is similar to templateFileName, but with
    // params[] as parameter values

    BufferedReader inFile = new BufferedReader(new FileReader(templateFileName));
    PrintWriter outFile = new PrintWriter(cfgFileName);

    String line = inFile.readLine();

    while (line != null) {
      int c_match = -1;
      for (int c = 1; c <= numParams; ++c) {
        if (line.startsWith(paramNames[c] + " ")) { c_match = c; break; }
      }

      if (c_match == -1) {
        outFile.println(line);
      } else {
        outFile.println(paramNames[c_match] + " " + params[c_match]);
      }

      line = inFile.readLine();
    }

    inFile.close();
    outFile.close();

  }

  private void copyFile(String sourceFileName, String targetFileName) throws Exception
  {
    InputStream inStream = new FileInputStream(new File(sourceFileName));
    BufferedReader inFile = new BufferedReader(new InputStreamReader(inStream, "utf8"));

    FileOutputStream outStream = new FileOutputStream(targetFileName, false); // false: don't append
    OutputStreamWriter outStreamWriter = new OutputStreamWriter(outStream, "utf8");
    BufferedWriter outFile = new BufferedWriter(outStreamWriter);

    String line;
    while(inFile.ready()) {
      line = inFile.readLine();
      writeLine(line, outFile);
    }

    inFile.close();
    outFile.close();
  }

  private void renameFile(String oldFileName, String newFileName)
  {
    if (fileExists(oldFileName)) {
      File oldFile = new File(oldFileName);
      File newFile = new File(newFileName);
      oldFile.renameTo(newFile);
    } else {
      println("Warning: file " + oldFileName + " does not exist! (in renameFile)",1);
    }
  }


  private void writeLine(String line, BufferedWriter writer) throws IOException {
    writer.write(line, 0, line.length());
    writer.newLine();
    writer.flush();
  }

  public void finish() throws Exception
  {
    if (decoderCommand == null) {
      myDecoder.cleanUp();
    }

    PrintWriter outFile_lambdas = new PrintWriter(finalLambdaFileName);
    for (int c = 1; c <= numParams; ++c) {
      outFile_lambdas.println(paramNames[c] + " ||| " + lambda[c]);
    }
    outFile_lambdas.close();

    // create config file with final values
    createConfigFile(lambda, decoderConfigFileName+".final.MERT",decoderConfigFileName+".orig.MERT");

    // resotre original config file
    copyFile(decoderConfigFileName+".orig.MERT",decoderConfigFileName);

    // delete copy of original config file
    File cp = new File(decoderConfigFileName+".orig.MERT");
    cp.delete();

  }

  private String[] cfgFileToArgsArray(String fileName) throws Exception
  {
    checkFile(fileName);

    Vector<String> argsVector = new Vector<String>();


    BufferedReader inFile = new BufferedReader(new FileReader(fileName));

    String line, origLine;
    do {
      line = inFile.readLine();
      origLine = line; // for error reporting purposes

      if (line != null && line.length() > 0 && line.charAt(0) != '#') {

        if (line.indexOf("#") != -1) { // discard comment
          line = line.substring(0,line.indexOf("#"));
        }

        line = line.trim();

        // now line should look like "-xxx XXX"

        String[] paramA = line.split("\\s+");

        if (paramA.length == 2 && paramA[0].charAt(0) == '-') {
          argsVector.add(paramA[0]);
          argsVector.add(paramA[1]);
        } else {
          println("Malformed line in config file:");
          println(origLine);
          System.exit(70);
        }

      }
    }  while (line != null);

    inFile.close();


    String[] argsArray = new String[argsVector.size()];

    for (int i = 0; i < argsVector.size(); ++i) {
      argsArray[i] = argsVector.elementAt(i);
    }

    return argsArray;
  }

  private void processArgsArray(String[] args) throws Exception
  {
    /* set default values */
    // Relevant files
    dirPrefix = null;
    sourceFileName = "source.txt";
    refFileName = "reference.txt";
    refsPerSen = 1;
    paramsFileName = "params.txt";
    finalLambdaFileName = "final_lambda.txt";
    // MERT specs
    metricName = "BLEU";
    maxMERTIterations = 20;
    saveInterFiles = true;
    initsPerIt = 20;
    oneModificationPerIteration = false;
    randInit = false;
    seed = System.currentTimeMillis();
//    useDisk = 2;
    // Decoder specs
    decoderCommandFileName = null;
    decoderOutFileName = "output.nbest";
    validDecoderExitValue = 0;
    decoderConfigFileName = "config.txt";
    sizeOfNBest = 100;
    // Output specs
    verbosity = 1;
    decVerbosity = 0;

    int i = 0;

    while (i < args.length) {
      String option = args[i];
      // Relevant files
      if (option.equals("-dir")) { dirPrefix = args[i+1]; }
      else if (option.equals("-s")) { sourceFileName = args[i+1]; }
      else if (option.equals("-r")) { refFileName = args[i+1]; }
      else if (option.equals("-rps")) {
        refsPerSen = Integer.parseInt(args[i+1]);
        if (refsPerSen < 1) { println("refsPerSen must be positive."); System.exit(10); }
      }
      else if (option.equals("-p")) { paramsFileName = args[i+1]; }
      else if (option.equals("-fin")) { finalLambdaFileName = args[i+1]; }
      // MERT specs
      else if (option.equals("-m")) {
        metricName = args[i+1];
        if (!EvaluationMetric.knownMetricName(metricName)) { println("Unknown metric name " + metricName + "."); System.exit(10); }
      }
      else if (option.equals("-maxIt")) {
        maxMERTIterations = Integer.parseInt(args[i+1]);
        if (maxMERTIterations < 1) { println("maxMERTIts must be positive."); System.exit(10); }
      }
      else if (option.equals("-save")) {
        int save = Integer.parseInt(args[i+1]);
        if (save == 1) saveInterFiles = true;
        else if (save == 0) saveInterFiles = false;
        else { println("save must be either 0 or 1."); System.exit(10); }
      }
      else if (option.equals("-ipi")) {
        initsPerIt = Integer.parseInt(args[i+1]);
        if (initsPerIt < 1) { println("initsPerIt must be positive."); System.exit(10); }
      }
      else if (option.equals("-opi")) {
        int opi = Integer.parseInt(args[i+1]);
        if (opi == 1) oneModificationPerIteration = true;
        else if (opi == 0) oneModificationPerIteration = false;
        else { println("oncePerIt must be either 0 or 1."); System.exit(10); }
      }
      else if (option.equals("-rand")) {
        int rand = Integer.parseInt(args[i+1]);
        if (rand == 1) randInit = true;
        else if (rand == 0) randInit = false;
        else { println("randInit must be either 0 or 1."); System.exit(10); }
      }
      else if (option.equals("-seed")) {
        if (args[i+1].equals("time")) {
          seed = System.currentTimeMillis();
        } else {
          seed = Long.parseLong(args[i+1]);
        }
      }
/*
      else if (option.equals("-ud")) {
        useDisk = Integer.parseInt(args[i+1]);
        if (useDisk < 0 || useDisk > 2) { println("useDisk should be between 0 and 2"); System.exit(10); }
      }
*/
      // Decoder specs
      else if (option.equals("-cmd")) { decoderCommandFileName = args[i+1]; }
      else if (option.equals("-decOut")) { decoderOutFileName = args[i+1]; }
      else if (option.equals("-decExit")) {
        validDecoderExitValue = Integer.parseInt(args[i+1]);
      }
      else if (option.equals("-dcfg")) { decoderConfigFileName = args[i+1]; }
      else if (option.equals("-N")) {
        sizeOfNBest = Integer.parseInt(args[i+1]);
        if (sizeOfNBest < 1) { println("N must be positive."); System.exit(10); }
      }
      // Output specs
      else if (option.equals("-v")) {
        verbosity = Integer.parseInt(args[i+1]);
        if (verbosity < 0 || verbosity > 4) { println("verbosity should be between 0 and 4"); System.exit(10); }
      }
      else if (option.equals("-decV")) {
        decVerbosity = Integer.parseInt(args[i+1]);
        if (decVerbosity < 0 || decVerbosity > 1) { println("decVerbosity should be either 0 or 1"); System.exit(10); }
      }
      else {
        println("Unknown option " + option); System.exit(10);
      }

      i += 2;

    } // while (i)

    if (dirPrefix != null) {
      sourceFileName = fullPath(dirPrefix,sourceFileName);
      refFileName = fullPath(dirPrefix,refFileName);
      decoderOutFileName = fullPath(dirPrefix,decoderOutFileName);
      paramsFileName = fullPath(dirPrefix,paramsFileName);
      finalLambdaFileName = fullPath(dirPrefix,finalLambdaFileName);
      if (decoderCommandFileName != null) {
        decoderCommandFileName = fullPath(dirPrefix,decoderCommandFileName);
      }
      decoderConfigFileName = fullPath(dirPrefix,decoderConfigFileName);
    }

    if (refsPerSen > 1) {
      // the provided refFileName might be a prefix
      File dummy = new File(refFileName);
      if (!dummy.exists()) {
        refFileName = createUnifiedRefFile(refFileName,refsPerSen);
      }
    } else {
      checkFile(refFileName);
    }

    checkFile(sourceFileName);
    checkFile(paramsFileName);
    if (decoderCommandFileName != null) {
      checkFile(decoderCommandFileName);
    }
    checkFile(decoderConfigFileName);



    println("Processed the following args array:",1);
    print("  ",1);
    for (i = 0; i < args.length; ++i) {
      print(args[i] + " ",1);
    }
    println("",1);
    println("",1);

  } // processArgs(String[] args)

  private void checkFile(String fileName)
  {
    if (!fileExists(fileName)) {
      println("The file " + fileName + " was not found!");
      System.exit(40);
    }
  }

  private boolean fileExists(String fileName)
  {
    File checker = new File(fileName);
    return checker.exists();
  }

  private String createUnifiedRefFile(String prefix, int numFiles) throws Exception
  {
    if (numFiles < 2) {
      println("Warning: createUnifiedRefFile called with numFiles = " + numFiles + "; doing nothing.",1);
      return prefix;
    } else {
      File checker;
      checker = new File(prefix+"1");

      if (!checker.exists()) {
        checker = new File(prefix+".1");
        if (!checker.exists()) {
          println("Can't find reference files.");
          System.exit(50);
        } else {
          prefix = prefix + ".";
        }
      }

      String outFileName;
      if (prefix.endsWith(".")) { outFileName = prefix+"all"; }
      else { outFileName = prefix+".all"; }

      PrintWriter outFile = new PrintWriter(outFileName);

      BufferedReader[] inFile = new BufferedReader[numFiles];

      int nextIndex;
      checker = new File(prefix+"0");
      if (checker.exists()) { nextIndex = 0; }
      else { nextIndex = 1; }
      int lineCount = countLines(prefix+nextIndex);

      for (int r = 0; r < numFiles; ++r) {
        if (countLines(prefix+nextIndex) != lineCount) {
          println("Line count mismatch in " + (prefix+nextIndex) + ".");
          System.exit(60);
        }
        inFile[r] = new BufferedReader(new FileReader(prefix+nextIndex));
        ++nextIndex;
      }

      String line;

      for (int i = 0; i < lineCount; ++i) {
        for (int r = 0; r < numFiles; ++r) {
          line = inFile[r].readLine();
          outFile.println(line);
        }
      }

      outFile.close();

      for (int r = 0; r < numFiles; ++r) { inFile[r].close(); }

      return outFileName;

    }

  } // createUnifiedRefFile(String prefix, int numFiles)

  private int countLines(String fileName) throws Exception
  {
    BufferedReader inFile = new BufferedReader(new FileReader(fileName));

    String line;
    int count = 0;
    do {
      line = inFile.readLine();
      if (line != null) ++count;
    }  while (line != null);

    inFile.close();

    return count;
  }

  private int countWords(String fileName) throws Exception
  {
    Scanner inFile = new Scanner(new FileReader(fileName));

    String word;
    int count = 0;
    while (inFile.hasNext()) {
      word = inFile.next();
      ++count;
    }

    inFile.close();

    return count;
  }

  private String fullPath(String dir, String fileName)
  {
    File dummyFile = new File(dir,fileName);
    return dummyFile.getAbsolutePath();
  }

  private void cleanupMemory()
  {
    cleanupMemory(100,false);
  }

  private void cleanupMemorySilently()
  {
    cleanupMemory(100,true);
  }

  private void cleanupMemory(int reps, boolean silent)
  {
    int bytesPerMB = 1024 * 1024;

    long totalMemBefore = myRuntime.totalMemory();
    long freeMemBefore = myRuntime.freeMemory();
    long usedMemBefore = totalMemBefore - freeMemBefore;


    long usedCurr = usedMemBefore; long usedPrev = usedCurr;

    // perform garbage collection repeatedly, until there is no decrease in
    // the amount of used memory
    for (int i = 1; i <= reps; ++i) {
      myRuntime.runFinalization();
      myRuntime.gc();
      (Thread.currentThread()).yield();

      usedPrev = usedCurr;
      usedCurr = myRuntime.totalMemory() - myRuntime.freeMemory();

      if (usedCurr == usedPrev) break;
    }


    if (!silent) {
      long totalMemAfter = myRuntime.totalMemory();
      long freeMemAfter = myRuntime.freeMemory();
      long usedMemAfter = totalMemAfter - freeMemAfter;

      println("GC: d_used = " + ((usedMemAfter - usedMemBefore) / bytesPerMB) + " MB (d_tot = " + ((totalMemAfter - totalMemBefore) / bytesPerMB) + " MB).",2);
    }
  }

  private void printMemoryUsage()
  {
    int bytesPerMB = 1024 * 1024;
    long totalMem = myRuntime.totalMemory();
    long freeMem = myRuntime.freeMemory();
    long usedMem = totalMem - freeMem;

    println("Allocated memory: " + (totalMem / bytesPerMB) + " MB (of which " + (usedMem / bytesPerMB) + " MB is being used).",2);
  }

  private void println(Object obj, int priority) { if (priority <= verbosity) println(obj); }
  private void print(Object obj, int priority) { if (priority <= verbosity) print(obj); }

  private void println(Object obj) { System.out.println(obj); }
  private void print(Object obj) { System.out.print(obj); }

  private void showProgress()
  {
    ++progress;
    if (progress % 10000 == 0) print(".",2);
  }



  private double[] randomLambda()
  {
    double[] retVal = new double[1+numParams];

    for (int c = 1; c <= numParams; ++c) {
      if (isOptimizable[c]) {
        double randVal = randGen.nextDouble(); // number in [0.0,1.0]
        randVal = randVal * (maxValue[c] - minValue[c]); // number in [0.0,max-min]
        randVal = minValue[c] + randVal; // number in [min,max]
        retVal[c] = randVal;
      } else {
        retVal[c] = defaultLambda[c];
      }
    }

    return retVal;
  }

/*
  private double[] getFeats(double[][][] featVal_array, int i, int k)
  {
    double[] retA = new double[1+numParams];

    for (int c = 1; c <= numParams; ++c) {
      retA[c] = featVal_array[c][i][k];
    }

    return retA;
  }
*/
  private void setFeats(double[][][] featVal_array, int i, int[] lastUsedIndex, int[] maxIndex, double[] featVal)
  {
    int k = lastUsedIndex[i] + 1;

    if (k > maxIndex[i]) {
      for (int c = 1; c <= numParams; ++c) {
        double[] temp = featVal_array[c][i];
        featVal_array[c][i] = new double[1+maxIndex[i]+sizeOfNBest];

        for (int k2 = 0; k2 <= maxIndex[i]; ++k2) {
          featVal_array[c][i][k2] = temp[k2];
        }
      }
      maxIndex[i] += sizeOfNBest;
//      cleanupMemorySilently(); // UNCOMMENT THIS
    }

    for (int c = 1; c <= numParams; ++c) {
      featVal_array[c][i][k] = featVal[c];
    }
    lastUsedIndex[i] += 1;
  }


  private HashSet<Integer> indicesToDiscard(double[] slope, double[] offset)
  {
    // some lines can be eliminated: the ones that have a lower offset
    // than some other line with the same slope.
    // That is, for any k1 and k2:
    //   if slope[k1] = slope[k2] and offset[k1] > offset[k2],
    //   then k2 can be eliminated.
    // (This is actually important to do as it eliminates a bug.)
    print("discarding: ",3);

    int numCandidates = slope.length;
    HashSet<Integer> discardedIndices = new HashSet<Integer>();
    HashMap<Double,Integer> indicesOfSlopes = new HashMap<Double,Integer>();
    // maps slope to index of best candidate that has that slope.
    // ("best" as in the one with the highest offset)

    for (int k1 = 0; k1 < numCandidates; ++k1) {
      double currSlope = slope[k1];
      if (!indicesOfSlopes.containsKey(currSlope)) {
        indicesOfSlopes.put(currSlope,k1);
      } else {
        int existingIndex = indicesOfSlopes.get(currSlope);
        if (offset[existingIndex] > offset[k1]) {
          discardedIndices.add(k1);
//          print(k1 + " ",3);
        } else if (offset[k1] > offset[existingIndex]) {
          indicesOfSlopes.put(currSlope,k1);
          discardedIndices.add(existingIndex);
//          print(existingIndex + " ",3);
        }
      }
    }


    // old way of doing it; takes quadratic time (vs. linear time above)
/*
    for (int k1 = 0; k1 < numCandidates; ++k1) {
      for (int k2 = 0; k2 < numCandidates; ++k2) {
        if (k1 != k2 && slope[k1] == slope[k2] && offset[k1] > offset[k2]) {
          discardedIndices.add(k2);
//          print(k2 + " ",3);
        }
      }
    }
*/

    println("",3);
    return discardedIndices;
  }
/*
  private void setSentencesOfInterest(TreeSet[] indicesOfInterest, Vector[] candidates) throws Exception
  {
    // process the merged decoder output file, and read the candidates
    // of interest
    BufferedReader inFile = new BufferedReader(new FileReader(decoderOutFileName+".temp.merged"));
    String line, candidate_str;

    for (int i = 0; i < numSentences; ++i) {
      int numCandidates = candidates[i].size();

      short currCand = 0;
      Iterator It = indicesOfInterest[i].iterator();

      while (It.hasNext()) {
        int nextIndex = (Integer)It.next();

        // skip candidates until you get to the nextKey'th candidate
        while (currCand < nextIndex) {
          line = inFile.readLine();
          ++currCand;
        }

        // now currCand == nextIndex, and the next line in inFile contains the sentence we want

//        line = inFile.readLine();
//        ++currCand;
//        line = line.substring(line.indexOf("||| ")+4); // get rid of initial text
//        candidate_str = line.substring(0,line.indexOf(" |||"));

        candidate_str = inFile.readLine();
        ++currCand;

        ((SentenceInfo)candidates[i].elementAt(nextIndex)).setSentence(candidate_str);

      }

      // skip the rest of ith sentence's candidates
      while (currCand < numCandidates) {
        line = inFile.readLine();
        ++currCand;
      }

    }

    inFile.close();

  } // setSentencesOfInterest(TreeSet[] indicesOfInterest, Vector[] candidates)
*/
  private void set_suffStats_array(TreeMap[] suffStats_array, TreeSet[] indicesOfInterest, Vector[] candidates) throws Exception
  {
    // process the merged sufficient statistics file, and read (and store) the
    // stats for candidates of interest
    BufferedReader inFile = new BufferedReader(new FileReader(decoderOutFileName+"temp.stats.merged"));
    String line, candidate_suffStats;

    for (int i = 0; i < numSentences; ++i) {
      int numCandidates = candidates[i].size();

      short currCand = 0;
      Iterator It = indicesOfInterest[i].iterator();

      while (It.hasNext()) {
        int nextIndex = (Integer)It.next();

        // skip candidates until you get to the nextKey'th candidate
        while (currCand < nextIndex) {
          line = inFile.readLine();
          ++currCand;
        }

        // now currCand == nextIndex, and the next line in inFile contains the sufficient statistics we want

        candidate_suffStats = inFile.readLine();
        ++currCand;

        String[] suffStats_str = candidate_suffStats.split("\\s+");

        double[] suffStats = new double[suffStatsCount];

        for (int s = 0; s < suffStatsCount; ++s) {
          suffStats[s] = Double.parseDouble(suffStats_str[s]);
        }

        suffStats_array[i].put(nextIndex,suffStats);

      }

      // skip the rest of ith sentence's candidates
      while (currCand < numCandidates) {
        line = inFile.readLine();
        ++currCand;
      }

    }

    inFile.close();

  } // set_suffStats_array(TreeMap[] suffStats_array, TreeSet[] indicesOfInterest, Vector[] candidates)

}
