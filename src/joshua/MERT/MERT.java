package joshua.MERT;
import java.math.*;
import java.util.*;
import java.io.*;
import java.text.DecimalFormat;

public class MERT
{
  static DecimalFormat f0 = new DecimalFormat("###0");
  static DecimalFormat f1 = new DecimalFormat("###0.0");
  static DecimalFormat f2 = new DecimalFormat("###0.00");
  static DecimalFormat f3 = new DecimalFormat("###0.000");
  static DecimalFormat f4 = new DecimalFormat("###0.0000");

  static final double NegInf = (-1.0 / 0.0);
  static final double PosInf = (+1.0 / 0.0);
  static final double epsilon = 1.0 / 1000000;

  static int progress;

  static int verbosity; // anything of priority <= verbosity will be printed
                        // (lower value for priority means more important)



  static int numSentences;
    // number of sentences in the dev set
    // (aka the "MERT training" set)

  static int refsPerSen;
    // number of reference translations per sentence

  static SentenceInfo[][] refSentenceInfo;
    // sentence information for the reference translations
    // refSentenceInfo[i][r] stores the information for the rth reference
    // translation of the ith sentence

  static int maxGramLength;
    // maximum gram length; needed for the SentenceInfo class

  static int numParams;
    // number of parameters for the log-linear model

  /* *********************************************************** */
  /*   NOTE: indexing starts at 1 in the following few arrays:   */
  /* *********************************************************** */

  static String[] paramNames;
    // parameter names, needed to read/create config file

  static double[] lambda;
    // the current parameter values. NOTE: indexing starts at 1.

  static boolean[] isOptimizable;
    // isOptimizable[c] = true iff lambda[c] should be optimized

  static double[] minValue;
  static double[] maxValue;
  static double[] precision;
    // when optimizing lambda[c], only values in [minValue,maxValue] will be
    // considered, quantized with a precision of precision[c].

    // E.g. minValue=-1.0, maxValue=+1.0, precision=0.05 means the possible
    // values to consider are: -1.00, -0.95, -0.90, ..., 0.95, +1.00

    // (*) minValue and maxValue can be real values as well as -Infinity and +Infinity
    //     (coded as -Inf and +Inf, respectively, in an input file)
    // (*) precision can be zero, in which case no quantization takes place.

  /* *********************************************************** */
  /* *********************************************************** */

  static String decoderCommand;
    // the command that runs the decoder; read from decoderCommandFileName

  static int decVerbosity;
    // verbosity level for decoder output.  If 0, decoder output is ignored.
    // If 1, decoder output is printed.

  static int validDecoderExitValue;
    // return value from running the decoder command that indicates success

  static boolean saveInterCfg;
    // if true, intermediate config files are saved.  If false, they are not.

  static int sizeOfNBest;
    // size of N-best list generated by decoder at each iteration
    // (aka simply N, but N is a bad variable name)

  static boolean resetCandList;
    // if true, the candidate list is cleared at the beginning of each MERT
    // iteration.  If false, the list is carried over to the next iteration.

  static boolean randInits;
    // if true, parameters are initialized randomly.  If false, parameters
    // are initialized using values from parameter file.

  static int runCount;
    // number of restarts.  If > 1, randInits must be set to true.

  static int maxMERTIterations;
    // maximum number of MERT iterations

  static boolean oneParamPerIteration;
    // if true, each MERT iteration examines all parameters but modifies up to
    // a single parameter (the most helpful).  If false, each MERT iteration
    // examines all parameters and could modify each parameter as it is
    // examined.

  static String metricName;
    // name of evaluation metric optimized by MERT

  static EvaluationMetric evalMetric;
    // the evaluation metric used by MERT

  static int suffStatsCount;
    // number of sufficient statistics for the evaluation metric

  static String dirPrefix; // where are all these files located?
  static String paramsFileName, finalLambdasFileName;
  static String sourceFileName, refFileName, decoderOutFileName;
  static String decoderConfigFileName, decoderCommandFileName;

  public static void main(String[] args) throws Exception
  {
    EvaluationMetric.set_knownNames();

    if (args.length == 0) {
      printUsage(args.length);
      System.exit(0);
    } else if (args.length == 1) {
      processArgsArray(cfgFileToArgsArray(args[0]));
    } else {
      processArgsArray(args);
    }
    // non-specified args will be set to default values in processArgsArray

    println("MERT started @ " + (new Date()),1);
    println("",1);

    initialize();
      // set numParams and numSentences, and initialize lambda[], 
      // and do any initialization required for the chosen evaluation metric

for (int r = 0; r < refsPerSen; ++r) {
  println("Testing evaluation metric calculation on reference set " + r + ":",2);
  test_score(refFileName, refsPerSen, r, true,2);
  println("",2);
}

    for (int run = 1; run <= runCount; ++run) {
      println("MERT run #" + run + " started @ " + (new Date()),1);
      println("",1);
      run_MERT(maxMERTIterations);
        // optimize lambda[]!!!
    }

println("Testing evaluation metric calculation on final decoder output:",2);
test_score(decoderOutFileName, sizeOfNBest, 0, false,2);
println("",2);

    finalize(finalLambdasFileName);
      // write final values to file

    System.exit(0);

  } // main(String[] args)

  private static void initialize() throws Exception
  {
    println("----------------------------------------------------",1);
    println("Initializing...",1);
    println("----------------------------------------------------",1);
    println("",1);

    numParams = countLines(paramsFileName);
    numSentences = countLines(sourceFileName);

    if (numSentences * refsPerSen != countLines(refFileName)) {
      println("Line count mismatch between " + sourceFileName + " and " + refFileName);
      System.exit(20);
    }
    // do we really need the source sentences ????????????????????????????????????????

    // create copy of config file
    copyFile(decoderConfigFileName,decoderConfigFileName+".orig.MERT");



    paramNames = new String[1+numParams];
    lambda = new double[1+numParams]; // indexing starts at 1 in these arrays
    isOptimizable = new boolean[1+numParams];
    minValue = new double[1+numParams];
    maxValue = new double[1+numParams];
    precision = new double[1+numParams];

    // read paramter names
    BufferedReader inFile_names = new BufferedReader(new FileReader(paramsFileName));

    for (int c = 1; c <= numParams; ++c) {
      String line = inFile_names.readLine();
      paramNames[c] = (line.substring(0,line.indexOf("|||"))).trim();
    }

    inFile_names.close();


    // initialize lambda[]
    Scanner inFile_init = new Scanner(new FileReader(paramsFileName));

    String dummy = "";

    for (int c = 1; c <= numParams; ++c) {
      while (!dummy.equals("|||")) { dummy = inFile_init.next(); }

      lambda[c] = inFile_init.nextDouble();

      dummy = inFile_init.next();
      if (dummy.equals("Opt")) { isOptimizable[c] = true; }
      else if (dummy.equals("Fix")) { isOptimizable[c] = false; }
      else { println("Unknown isOptimizable string " + dummy + " (must be either Opt or Fix)"); System.exit(21); }

      dummy = inFile_init.next();
      if (dummy.equals("-Inf")) { minValue[c] = NegInf; }
      else if (dummy.equals("+Inf")) { minValue[c] = PosInf; } // who'd ever do that!?
      else { minValue[c] = Double.parseDouble(dummy); }

      dummy = inFile_init.next();
      if (dummy.equals("-Inf")) { maxValue[c] = NegInf; } // who'd ever do that!?
      else if (dummy.equals("+Inf")) { maxValue[c] = PosInf; }
      else { maxValue[c] = Double.parseDouble(dummy); }

      if (minValue[c] == maxValue[c] && isOptimizable[c]) {
        println("Warning: lambda[" + c + "] is optimizable but has minValue = maxValue = " + minValue[c] + ".",1);
        println("         This makes it a fixed parameter at " + minValue[c] + ".",1);
        isOptimizable[c] = false;
        lambda[c] = minValue[c];
      } else if (minValue[c] > maxValue[c]) {
        println("minValue[" + c + "]=" + minValue[c] + " > " + maxValue[c] + "=maxValue[" + c + "]!");
        System.exit(21);
      }

      precision[c] = inFile_init.nextDouble();
      if (precision[c] < 0) {
        println("precision[" + c + "]=" + precision[c] + " < 0!  Must be non-negative.");
        System.exit(21);
      }

      if (!(minValue[c] <= lambda[c] && lambda[c] <= maxValue[c]) && isOptimizable[c]) {
        println("Warning: lambda[" + c + "] is optimizable but has initial value (" + lambda[c] + ")",1);
        println("         that is outside its specified interval [" + minValue[c] + "," + maxValue[c] + "]",1);
      }

    }

    inFile_init.close();


    SentenceInfo.setMaxGramLength(maxGramLength);
    SentenceInfo.setNumParams(numParams);


    refSentenceInfo = new SentenceInfo[numSentences][refsPerSen];

    // read in reference sentences

    BufferedReader inFile_refs = new BufferedReader(new FileReader(refFileName));
    String line;

    for (int i = 0; i < numSentences; ++i) {
      for (int r = 0; r < refsPerSen; ++r) {
        // read the rth reference translation for the ith sentence
        line = inFile_refs.readLine();
        refSentenceInfo[i][r] = new SentenceInfo(line);
      }
    }

    inFile_refs.close();


    // read in decoder command

    BufferedReader inFile_comm = new BufferedReader(new FileReader(decoderCommandFileName));
    decoderCommand = inFile_comm.readLine();
    inFile_comm.close();

    // set static data members for the EvaluationMetric class
    EvaluationMetric.set_numSentences(numSentences);
    EvaluationMetric.set_refsPerSen(refsPerSen);
    EvaluationMetric.set_refSentenceInfo(refSentenceInfo);

    // do necessary initialization for the evaluation metric
    if (metricName.equals("BLEU")) {
      evalMetric = new BLEU(maxGramLength);
    } else if (metricName.equals("01LOSS")) {
      evalMetric = new ZeroOneLoss();
    }

    suffStatsCount = evalMetric.get_suffStatsCount();

    println("numSentences = " + numSentences,1);
    println("numParams = " + numParams,1);
    print("  {",1);
    for (int c = 1; c <= numParams; ++c) {
      print("\"" + paramNames[c] + "\"",1);
      if (c < numParams) print(",",1);
    }
    println("}",1);
    println("",1);

    println("c    initial\toptimizable?    range",1);

    for (int c = 1; c <= numParams; ++c) {
      print(c + "    " + f3.format(lambda[c]) + "\t",1);
      if (isOptimizable[c]) print("   Yes          ",1);
      else print("   No           ",1);
      print("[" + minValue[c] + "," + maxValue[c] + "] @ " + precision[c] + " precision",1);
      println("",1);
    }

    println("",1);

    println("----------------------------------------------------",1);
    println("",1);

  } // void initialize(...)

  private static void run_MERT(int maxIts) throws Exception
  {
    Vector[] candidates = new Vector[numSentences];
      // candidates[i] stores the translation candidates for the ith sentence
      // each element in the array is a Vector of SentenceInfo objects

    HashSet[] candidatesSentences = new HashSet[numSentences];
      // only stores sentences

      // ***********************************************************
      // *** old implementation not using the SentenceInfo class ***
      // ***********************************************************
//    HashMap[] candidatesInfo = new HashMap[numSentences];
      // candidatesInfo[i] stores the translation candidates for the ith sentence
      // each element in the array is a <candidate sentence,featVal[]> HashMap
      // The jth feature function is also known as h_j.
      // ***************************************************************

    for (int i = 0; i < numSentences; ++i) {
      candidatesSentences[i] = new HashSet();
      candidates[i] = new Vector();
    }

    if (randInits) {
      long mySeed = System.currentTimeMillis();
      println("Initializing lambda[] randomly; using seed " + mySeed,1);
      Random randGen = new Random(mySeed);

      // initialize optimizable parameters randomly (sampling uniformly from that parameter's range)
      for (int c = 1; c <= numParams; ++c) {
        if (isOptimizable[c]) {

          double randVal = randGen.nextDouble(); // number in [0.0,1.0]
          randVal = randVal * (maxValue[c] - minValue[c]); // number in [0.0,max-min]
          randVal = minValue[c] + randVal; // number in [min,max]
          lambda[c] = randVal;
        }
      }
    }

    println("Initial lambda[]: " + lambdaToString(),1);

    int totalCandidateCount = 0;
      // total number of candidates stored in candidates[]

    for (int iteration = 1; iteration <= maxIts; ++iteration) {

      println("Starting MERT iteration #" + iteration + " @ " + (new Date()),1);

      if (iteration > 1 && resetCandList) {
        println("Clearing candidate translations from previous MERT iteration.",1);
        for (int i = 0; i < numSentences; ++i) { candidates[i].clear(); }
        totalCandidateCount = 0;
      } else if (iteration > 1) {
        print("Carrying over " + totalCandidateCount + " candidate translations from previous MERT iteration.",1);
        println(" (About " + totalCandidateCount/numSentences + " candidate translations per sentence.)",1);
      }

      // initCandidateCount[i] stores number of candidate translations added
      // so far for the ith sentence, before generation of the N-best set
      // in the current MERT iteration.

      int[] initCandidateCount = new int[numSentences];
      for (int i = 0; i < numSentences; ++i) {
        initCandidateCount[i] = candidates[i].size();
      }

      // run the decoder on all the sentences, producing for each sentence a set of
      // sizeOfNBest candidates, with numParams feature values for each candidate

      /******************************/
      // CREATE DECODER CONFIG FILE //
      /******************************/

      createConfigFile(lambda,decoderConfigFileName,decoderConfigFileName+".orig.MERT");

      /***************/
      // RUN DECODER //
      /***************/

      println("Running decoder...",1);

      Runtime rt = Runtime.getRuntime();
      Process p = rt.exec (decoderCommand);
      InputStream is = p.getErrorStream();
      InputStreamReader isr = new InputStreamReader(is);
      BufferedReader br = new BufferedReader(isr);
      String dummy_line = null;
      while ((dummy_line = br.readLine()) != null) {
        if (decVerbosity == 1) {
          println(dummy_line);
        }
      }
      int decStatus = p.waitFor();

      if (decStatus != validDecoderExitValue) {
        println("Call to decoder returned " + decStatus + "; was expecting " + validDecoderExitValue + ".");
        System.exit(30);
      }

      println("...finished decoding @ " + (new Date()),1);

      println("Ensuring proper decoder output.",2);

      checkFile(decoderOutFileName);

      fixDecoderOutput();
        // makes sure each sentence has sizeOfNBest candidate translations in
        // decoderOutFileName, since some sentences might produce fewer
        // candidates (e.g. sentence is too short or has too many OOV's)

      println("Reading candidate translations.",1);
      progress = 0;

      BufferedReader inFile = new BufferedReader(new FileReader(decoderOutFileName));
      String line, candidate_str;

      boolean newCandidatesAdded = false;

      for (int i = 0; i < numSentences; ++i) {
        for (int n = 0; n < sizeOfNBest; ++n) {

          // read nth candidate for the ith sentence, along with its feature values,
          // and then add them to candidates[i], if not already there

/*
line format:

.* ||| words of candidate translation . ||| feat-1_val feat-2_val ... feat-numParams_val .*

*/

          line = inFile.readLine();
          line = line.substring(line.indexOf("||| ")+4); // get rid of initial text
          candidate_str = line.substring(0,line.indexOf(" |||"));

          if (!candidatesSentences[i].contains(candidate_str.intern())) {
            SentenceInfo candidate = new SentenceInfo(candidate_str.intern());
            print("Adding candidate " + n + " of sentence " + i + ": ",3);
            line = line.substring(line.indexOf("||| ")); // get rid of candidate

            String[] featVal_str = line.split("\\s+");
              // extract feature values
              // [0] will be |||, otherwise [i] will be feat-i_val

            double[] featVal = new double[1+numParams];


/*
            for (int c = 1; c <= numParams; ++c) {
              featVal[c] = Double.parseDouble(featVal_str[c]);
            }
*/

            //debugging version
            for (int c = 1; c <= numParams; ++c) {
              featVal[c] = Double.parseDouble(featVal_str[c]);
              print("fV[" + c + "]=" + featVal[c] + " ",3);
            }
            println("",3);


            featVal[0] = n; // order of appearance in file
            candidatesSentences[i].add(candidate_str.intern());
            candidate.set_featVals(featVal);
            candidates[i].add(candidate);
            ++totalCandidateCount;
            newCandidatesAdded = true;

          } else {
            println("Skipping candidate " + n + " of sentence " + i + " (already seen)",3);
          }

          showProgress();

        } // for (n)
      } // for (i)

      println("",1);

      inFile.close();

      if (!newCandidatesAdded) {
        println("Note: No new candidates added in this iteration.",1);
        // no new candidate translations; not necessarily done (if doing one
        // parameter per MERT iteration).
      }

      boolean anyParamChanged = false;
      boolean[] paramChanged = new boolean[1+numParams];
      for (int c = 1; c <= numParams; ++c) { paramChanged[c] = false; }

      if (oneParamPerIteration) {

        double baseScore = score(lambda,candidates);
        println("(Base score: " + baseScore + ")",1);

        int c_best = 0;
        double bestLambdaVal = 0.0;
        double bestScore = evalMetric.worstPossibleScore()-1;

        for (int c = 1; c <= numParams; ++c) {
        // investigate lambda[c]

          if (!isOptimizable[c]) {
            println("Not investigating lambda[" + c + "]",1);
          } else {
            println("Investigating lambda[" + c + "]",1);

            double[] bestScoreInfo_c = line_opt(c,candidates);
              // get best score and its lambda value

            double bestScore_c = bestScoreInfo_c[0];
            double bestLambdaVal_c = bestScoreInfo_c[1];

            if (evalMetric.isBetter(bestScore_c,bestScore)) {
              bestScore = bestScore_c;
              c_best = c;
              bestLambdaVal = bestLambdaVal_c;
            }

          } // if (!isOptimizable[c])

        }

        // now c_best is the parameter giving the best result

        if (evalMetric.isBetter(bestScore,baseScore)) {
          println("*** Changing lambda[" + c_best + "] from " + f4.format(lambda[c_best]) + " (score: " + f4.format(baseScore) + ") to " + f4.format(bestLambdaVal) + " (score: " + f4.format(bestScore) + ") ***",1);

          println("*** Old lambda[]: " + lambdaToString() + " ***",1);
          lambda[c_best] = bestLambdaVal;
          println("*** New lambda[]: " + lambdaToString() + " ***",1);

          paramChanged[c_best] = true;
          anyParamChanged = true;
        } else {
          println("*** No change to any lambda ***",1);
          println("*** lambda[]: " + lambdaToString() + " ***",1);
        }

      } else {

        for (int c = 1; c <= numParams; ++c) {
        // optimize lambda[c]

          if (!isOptimizable[c]) {
            println("Not optimizing lambda[" + c + "]",1);
          } else {
            println("Optimizing lambda[" + c + "]",1);

            double baseScore = score(lambda,candidates);
            println("(Base score: " + baseScore + ")",1);

            double[] bestScoreInfo_c = line_opt(c,candidates);
              // get best score and its lambda value

            double bestScore_c = bestScoreInfo_c[0];
            double bestLambdaVal_c = bestScoreInfo_c[1];

            if (evalMetric.isBetter(bestScore_c,baseScore)) {
              println("*** Changing lambda[" + c + "] from " + f4.format(lambda[c]) + " (score: " + f4.format(baseScore) + ") to " + f4.format(bestLambdaVal_c) + " (score: " + f4.format(bestScore_c) + ") ***",1);

              println("*** Old lambda[]: " + lambdaToString() + " ***",1);
              lambda[c] = bestLambdaVal_c;
              println("*** New lambda[]: " + lambdaToString() + " ***",1);

              lambda[c] = bestLambdaVal_c;
              paramChanged[c] = true;
              anyParamChanged = true;
            } else {
              println("*** No change to lambda[" + c + "] ***",1);
              println("*** lambda[]: " + lambdaToString() + " ***",1);
            }

          } // if (!isOptimizable[c])

        } // for (c)

      }

      if (!anyParamChanged) {
        println("No parameter values changed in this iteration; exiting MERT.",1);
        break;
      }

      if (saveInterCfg) {
        // create config file with current values
        createConfigFile(lambda, decoderConfigFileName+"."+iteration,decoderConfigFileName+".orig.MERT");
      }

    } // for (iteration)

  } // void run_MERT(int maxIts)

  private static String lambdaToString()
  {
    String retStr = "{";
    for (int c = 1; c <= numParams-1; ++c) {
      retStr += "" + lambda[c] + ", ";
    }
    retStr += "" + lambda[numParams] + "}";

    return retStr;
  }

  public static double[] line_opt(int c, Vector[] candidates)
  {
    /* OLD; using 2-d array
    TreeMap[][] thresholds = new TreeMap[numSentences][1+numParams];
    */

    TreeMap[] thresholds = new TreeMap[numSentences];
      // thresholds[i] stores thresholds for the cth parameter obtained by
      // processing the candidates of sentence i.  It not only stores the
      // thresholds themselves, but also a triple of {i,from,to}, where from/to
      // are indices that characterize the 1-best switch at this threshold.

    for (int i = 0; i < numSentences; ++i) {
//      for (int c = 1; c <= numParams; ++c) {
        thresholds[i] = new TreeMap();
//      }
    }

          double[] bestScoreInfo = new double[2];

          // Find threshold points

          int ipCount = 0;
          for (int i = 0; i < numSentences; ++i) {
          // find threshold points contributed by ith sentence

            println("Processing the " + i + "th sentence",3);

            thresholds[i].clear();

            int numCandidates = candidates[i].size();
              // aka simply K

            double[] slope = new double[numCandidates];
              // will be h_c from candidatesInfo
              // repeated here for easy access
            double[] offset = new double[numCandidates];
              // SUM_j!=c lambda_j*h_j(x)

            int minSlopeIndex = -1;          // index of line with steepest descent...
            double minSlope = PosInf;        // ...and its slope...
            double offset_minSlope = NegInf; // ...and its offset (needed to break ties)

            int maxSlopeIndex = -1;          // index of line with steepest ascent...
            double maxSlope = NegInf;        // ...and its slope...
            double offset_maxSlope = NegInf; // ...and its offset (needed to break ties)

            SentenceInfo SI = null;
            for (int k = 0; k < numCandidates; ++k) {
              SI = (SentenceInfo)candidates[i].elementAt(k);
              double[] featVal = SI.getFeats();

              slope[k] = featVal[c];

              offset[k] = 0.0f;
              for (int c2 = 1; c2 <= numParams; ++c2) {
                if (c2 != c) { offset[k] += lambda[c2]*featVal[c2]; }
              }

              // debugging
              println("@ (i,k,n)=(" + i + "," + k + "," + (int)featVal[0] + "), "
                     + "slope = " + slope[k] + "; offset = " + offset[k],3);

              if (slope[k] < minSlope || (slope[k] == minSlope && offset[k] > offset_minSlope)) {
                minSlopeIndex = k;
                minSlope = slope[k];
                offset_minSlope = offset[k];
              }

              if (slope[k] > maxSlope || (slope[k] == maxSlope && offset[k] > offset_maxSlope)) {
                maxSlopeIndex = k;
                maxSlope = slope[k];
                offset_maxSlope = offset[k];
              }
            }

            // PS: now k equals numCandidates-1

            // debugging
            println("minSlope is @ k = " + minSlopeIndex + ": slope " + minSlope + " (offset " + offset_minSlope + ")",3);
            println("maxSlope is @ k = " + maxSlopeIndex + ": slope " + maxSlope + " (offset " + offset_maxSlope + ")",3);


            // some lines can be eliminated: the ones that have a lower offset
            // than any other line with the same slope.
            // That is, for any k1 and k2:
            //   if slope[k1] = slope[k2] and offset[k1] > offset[k2],
            //   then k2 can be eliminated.
            // (This is actually important to do as it eliminates a bug.)

            HashSet discardedIndices = new HashSet();
            print("discarding: ",3);
            for (int k1 = 0; k1 < numCandidates; ++k1) {
              for (int k2 = 0; k2 < numCandidates; ++k2) {
                if (k1 != k2 && slope[k1] == slope[k2] && offset[k1] > offset[k2]) {
                  discardedIndices.add(k2);
                  print(k2 + " ",3);
                }
              }
            }
            println("",3);

            println("Extracting thresholds[(i,c)=(" + i + "," + c + ")]",3);

            int currIndex = minSlopeIndex;
              // As we traverse the lambda_c dimension, the "winner" candidate will
              // change at intersection points.  currIndex tells us which candidate
              // is the winner in the interval currently under investigation.

              // We traverse the lambda_c dimension starting at -Inf.  The line with
              // steepest descent is the winner as lambda_c -> -Inf, so we initialize
              // currIndex to minSlopeIndex to reflect that fact.

              // Similarly, the winner as lambda_c -> +Inf is the line with the
              // steepest *ascent* (i.e. max slope), and so we continue finding
              // intersection points until we hit that line.

            while (currIndex != maxSlopeIndex) {

              print("cI=" + currIndex + " ",3);

              // find the candidate whose line is the first to intersect the current
              // line.  ("first" meaning with an intersection point that has the
              //         lowest possible lambda_c value.)

              double nearestIntersectionPoint = PosInf;
              int nearestIntersectingLineIndex = -1;

              for (int k = 0; k < numCandidates; ++k) {
                if (slope[k] > slope[currIndex] && !discardedIndices.contains(k)) {
                // only higher-sloped lines will intersect the current line
                // (If we didn't have discardedIndices a bug would creep up here.)

                  // find intersection point ip_k
                  double ip_k = (offset[k] - offset[currIndex])/(slope[currIndex] - slope[k]);
                  if (ip_k < nearestIntersectionPoint) {
                    nearestIntersectionPoint = ip_k;
                    nearestIntersectingLineIndex = k;
                  }
                }
              }

              print("ip=" + f4.format(nearestIntersectionPoint) + " ",3);
              ++ipCount;

              int[] th_info = {i,currIndex,nearestIntersectingLineIndex};

              thresholds[i].put(nearestIntersectionPoint,th_info);
                // i.e., at lambda_c = nIP, the (index of the) 1-best changes
                // from currIndex to nearestIntersectingLineIndex (which is
                // indicated in th_info)

              currIndex = nearestIntersectingLineIndex;

            } // end while (currIndex != maxSlopeIndex)

            println("cI=" + currIndex + "(=? " + maxSlopeIndex + " = mxSI)",3);

            // now thresholds[i] has the values for lambda_c at which score changes
            // based on the candidates for the ith sentence

            println("",3);

          } // for (i)

          TreeMap thresholdsAll = new TreeMap();
          for (int i = 0; i < numSentences; ++i) {
            Iterator It = (thresholds[i].keySet()).iterator();
            while (It.hasNext()) {
              double ip = (Double)It.next();
              if (ip > minValue[c] && ip < maxValue[c]) {
                if (!thresholdsAll.containsKey(ip)) {
                  Vector A = new Vector();
                  A.add(thresholds[i].get(ip));
                  thresholdsAll.put(ip,A);
                } else { // not likely to happen, but should account for it
                  Vector A = (Vector)thresholdsAll.get(ip);
                  A.add(thresholds[i].get(ip));
                  thresholdsAll.put(ip,A);
                }
              }
            }
          }

          // now thresholdsAll has the values for lambda_c at which score changes
          // based on the candidates for *all* the sentences (that satisfy
          // range constraints).
          // Each lambda_c value maps to a Vector of th_info.  All of these
          // Vectors are probably of size 1.



          /*************************************************/
          /*************************************************/

          double smallest_th = (Double)thresholdsAll.firstKey();
          double largest_th = (Double)thresholdsAll.lastKey();
          println("Smallest extracted threshold: " + smallest_th,3);
          println("Largest extracted threshold: " + largest_th,3);
          println("",3);

          if (maxValue[c] != PosInf) {
            thresholdsAll.put(maxValue[c],null);
          } else {
            thresholdsAll.put(((Double)thresholdsAll.lastKey() + 0.1),null);
          }

          int[] indexOfCurrBest = new int[numSentences];
            // As we traverse lambda_c, indexOfCurrBest indicates which is the
            // current best candidate.

          double[][] suffStats = new double[numSentences][suffStatsCount];
            // suffStats[i][s] stores the contribution to the sth sufficient
            // statistic from the candidate for the ith sentence (the candidate
            // indicated by indexOfCurrBest[i]).

          double[] suffStats_tot = new double[suffStatsCount];
            // suffStats_tot[s] := SUM_i suffStats[i][s]

          for (int s = 0; s < suffStatsCount; ++s) { suffStats_tot[s] = 0; }

          // initialize indexOfCurrBest[]

          double[] temp_lambda = new double[1+numParams];
          System.arraycopy(lambda,1,temp_lambda,1,numParams);

          double ip_prev = 0.0, ip_curr = 0.0;

          if (minValue[c] != NegInf) {
            temp_lambda[c] = (minValue[c] + smallest_th) / 2.0;
            ip_curr = minValue[c];
          } else {
            temp_lambda[c] = smallest_th - 0.05;
            ip_curr = smallest_th - 0.1;
          }

          for (int i = 0; i < numSentences; ++i) {
            int numCandidates = candidates[i].size();

            double max = NegInf;
            int indexOfMax = -1;
            for (int k = 0; k < numCandidates; ++k) {
              double score = 0;
              double[] featVals = ((SentenceInfo)candidates[i].elementAt(k)).getFeats();

              for (int c2 = 1; c2 <= numParams; ++c2) { score += temp_lambda[c2] * featVals[c2]; }
              if (score > max) {
                max = score;
                indexOfMax = k;
              }
            }

            indexOfCurrBest[i] = indexOfMax;

          }

          // Now, set suffStats[][], and increment suffStats_tot[]
          for (int i = 0; i < numSentences; ++i) {
            suffStats[i] = evalMetric.suffStats((SentenceInfo)candidates[i].elementAt(indexOfCurrBest[i]),i);

            for (int s = 0; s < suffStatsCount; ++s) {
              suffStats_tot[s] += suffStats[i][s];
            }
          }


          double bestScore = evalMetric.score(suffStats_tot);
          double bestLambdaVal = temp_lambda[c];
          double nextLambdaVal = bestLambdaVal;
          println("At lambda[" + c + "] = " + bestLambdaVal + ",\t" + metricName + " = " + bestScore + " (*)",3);

          Iterator It = (thresholdsAll.keySet()).iterator();
          if (It.hasNext()) { ip_curr = (Double)It.next(); }

          while (It.hasNext()) {
            ip_prev = ip_curr;
            ip_curr = (Double)It.next();
            nextLambdaVal = (ip_prev + ip_curr)/2.0;

            Vector th_info_V = (Vector)thresholdsAll.get(ip_prev);
            for (int t = 0; t < th_info_V.size(); ++t) {
              int[] th_info = (int[])th_info_V.elementAt(t);
              int i = th_info[0];
              int old_k = th_info[1]; // should be equal to indexOfCurrBest[i]
              int new_k = th_info[2];

              for (int s = 0; s < suffStatsCount; ++s) {
                suffStats_tot[s] -= suffStats[i][s]; // subtract stats for candidate old_k
              }

              indexOfCurrBest[i] = new_k;
              suffStats[i] = evalMetric.suffStats((SentenceInfo)candidates[i].elementAt(indexOfCurrBest[i]),i);

              for (int s = 0; s < suffStatsCount; ++s) {
                suffStats_tot[s] += suffStats[i][s]; // add stats for candidate old_k
              }

            }

            double nextTestScore = evalMetric.score(suffStats_tot);
            print("At lambda[" + c + "] = " + nextLambdaVal + ",\t" + metricName + " = " + nextTestScore,3);

            if (evalMetric.isBetter(nextTestScore,bestScore)) {
              bestScore = nextTestScore;
              bestLambdaVal = nextLambdaVal;
              print(" (*)",3);
            }
            println("",3);

          }

          if (maxValue[c] != PosInf) {
            nextLambdaVal = (largest_th + maxValue[c]) / 2.0;
          } else {
            nextLambdaVal = largest_th + 0.05;
          }

          /*************************************************/
          /*************************************************/

          bestScoreInfo[0] = bestScore;
          bestScoreInfo[1] = bestLambdaVal;

          return bestScoreInfo;

  } // double[] line_opt(int c)


  private static void fixDecoderOutput() throws Exception
  {
    copyFile(decoderOutFileName,decoderOutFileName+".temp.MERT");
    BufferedReader inFile = new BufferedReader(new FileReader(decoderOutFileName+".temp.MERT"));
    PrintWriter outFile = new PrintWriter(decoderOutFileName);
    String line, prevLine;

    int i = 0; int n = 0;
    line = inFile.readLine();
    prevLine = "";

    while (line != null) {

/*
line format:

.* ||| words of candidate translation . ||| feat-1_val feat-2_val ... feat-numParams_val .*

*/

      // in a well formed file, we'd find the nth candidate for the ith sentence

      int read_i = Integer.parseInt(line.substring(0,line.indexOf(" |||")));

      if (read_i != i) { // bad; add dummy copies of last seen candidate
        while (n < sizeOfNBest) {
          outFile.println(prevLine);
          ++n;
        }
        n = 0; ++i;
      }

      outFile.println(line);
      ++n;
      if (n == sizeOfNBest) { n = 0; ++i; }

      prevLine = line;
      line = inFile.readLine();
    }

    if (i != numSentences) { // last sentence had too few candidates
      while (n < sizeOfNBest) {
        outFile.println(prevLine);
        ++n;
      }
    }

    inFile.close();
    outFile.close();

    // delete temp copy of old decoder output
    File cp = new File(decoderOutFileName+".temp.MERT");
    cp.delete();

  }

  private static void createConfigFile(double[] params, String cfgFileName, String templateFileName) throws Exception
  {
    // i.e. create cfgFileName, which is similar to templateFileName, but with
    // params[] as parameter values

    BufferedReader inFile = new BufferedReader(new FileReader(templateFileName));
    PrintWriter outFile = new PrintWriter(cfgFileName);

    String line = inFile.readLine();

    while (line != null) {
      int c_match = -1;
      for (int c = 1; c <= numParams; ++c) {
        if (line.startsWith(paramNames[c] + " ")) { c_match = c; break; }
      }

      if (c_match == -1) {
        outFile.println(line);
      } else {
        outFile.println(paramNames[c_match] + " " + params[c_match]);
      }

      line = inFile.readLine();
    }

    inFile.close();
    outFile.close();

  }

  private static void copyFile(String sourceFileName, String targetFileName) throws Exception
  {
    InputStream inStream = new FileInputStream(new File(sourceFileName));
    BufferedReader inFile = new BufferedReader(new InputStreamReader(inStream, "utf8"));

    FileOutputStream outStream = new FileOutputStream(targetFileName, false); // false: don't append
    OutputStreamWriter outStreamWriter = new OutputStreamWriter(outStream, "utf8");
    BufferedWriter outFile = new BufferedWriter(outStreamWriter);

    String line;
    while(inFile.ready()) {
      line = inFile.readLine();
      writeLine(line, outFile);
    }

    inFile.close();
    outFile.close();
  }


  private static void writeLine(String line, BufferedWriter writer) throws IOException {
    writer.write(line, 0, line.length());
    writer.newLine();
    writer.flush();
  }



private static void test_score(String inFileName, int candPerSen, int testIndex, boolean isRefFile, int v) throws Exception
{
    // test that the translations in inFileName get the expected scores

    // candPerSen: how many candidates are provided per sentence?
    // testIndex: which of the candidates (for each sentence) should be tested?
    //            e.g. testIndex=0 means first candidate should be evaluated
    //                 testIndex=candPerSen-1 means last candidate should be evaluated
    // isRefFile: if true, then no formatting; if false, then decoder output format

    if (candPerSen < 0) {
      println("candPerSen must be positive.");
      System.exit(30);
    }

    if (testIndex < 0 || testIndex > candPerSen-1) {
      println("testIndex must be in [0,candPerSen-1]");
      System.exit(31);
    }

    // read the candidates
    SentenceInfo[] candSentenceInfo = new SentenceInfo[numSentences];

    BufferedReader inFile = new BufferedReader(new FileReader(inFileName));
    String line, candidate_str;

    for (int i = 0; i < numSentences; ++i) {

      for (int n = 0; n < testIndex; ++n){
      // skip candidates 0 through testIndex-1
        line = inFile.readLine();
      }

      // read candidate testIndex
      line = inFile.readLine();

      if (isRefFile) {
        candidate_str = line;
      } else {
        line = line.substring(line.indexOf("||| ")+4); // get rid of initial text
        candidate_str = line.substring(0,line.indexOf(" |||"));
      }

      candSentenceInfo[i] = new SentenceInfo(candidate_str);

      for (int n = testIndex+1; n < candPerSen; ++n){
      // skip candidates testIndex+1 through candPerSen-1
        line = inFile.readLine();
      }

    }

    inFile.close();

    if (v <= verbosity) {
      evalMetric.print_detailed_score(candSentenceInfo);
    }

} // void test_score(...)






  private static double score(double[] lambda, Vector[] candidates) throws Exception
  {
    SentenceInfo[] candSentenceInfo = new SentenceInfo[numSentences];

    BufferedReader inFile = new BufferedReader(new FileReader(decoderOutFileName));
    String line, candidate_str;

    for (int i = 0; i < numSentences; ++i) {
      int numCandidates = candidates[i].size();
      double max = NegInf;
      int indexOfMax = -1;

      for (int k = 0; k < numCandidates; ++k) {
        double score = 0;
        double[] featVals = ((SentenceInfo)candidates[i].elementAt(k)).getFeats();
        for (int c = 1; c <= numParams; ++c) {
          score += lambda[c] * featVals[c];
        }
        if (score > max) {
          max = score;
          indexOfMax = k;
        }
      }

      candSentenceInfo[i] = new SentenceInfo((SentenceInfo)candidates[i].elementAt(indexOfMax));
    }

    inFile.close();

    return evalMetric.score(candSentenceInfo);

  }

  private static void finalize(String finalLambdasfileName) throws Exception
  {
    PrintWriter outFile_lambdas = new PrintWriter(finalLambdasfileName);
    for (int c = 1; c <= numParams; ++c) {
      outFile_lambdas.println(lambda[c]);
    }
    outFile_lambdas.close();

    // create config file with final values
    createConfigFile(lambda, decoderConfigFileName+".final.MERT",decoderConfigFileName+".orig.MERT");

    // resotre original config file
    copyFile(decoderConfigFileName+".orig.MERT",decoderConfigFileName);

    // delete copy of original config file
    File cp = new File(decoderConfigFileName+".orig.MERT");
    cp.delete();

  }

  private static void printUsage(int argsLen)
  {
    println("Oops, you provided " + argsLen + " args!");
    println("");
    println("Usage:");
    println(" MERT MERT_configFile");
    println("");
    println("   OR:");
    println("");
    println(" MERT [-dir dirPrefix] [-s sourceFile] [-r refFile] [-rps refsPerSen]\n      [-maxGL maxGramLength] [-decOut decoderOutFile] [-decExit validExit]\n      [-p paramsFile] [-rand randInits] [-runs runCount] [-seed firstSeed]\n      [-N N] [-maxIt maxMERTIts] [-dcfg decConfigFile] [-save saveInterCfg]\n      [-cmd commandFile] [-opi onePerIt] [-m metricName] [-fin finalLambdas]\n      [-xx xxx] [-v verbosity]");
    println("");
    println(" (*) -dir dirPrefix: location of relevant files\n       [[default: null string (i.e. they are in the current directory)]]");
    println(" (*) -s sourceFile: source sentences (foreign sentences) of the MERT dataset\n       [[default: source.txt]]");
    println(" (*) -r refFile: target sentences (reference translations) of the MERT dataset\n       [[default: reference.txt]]");
    println(" (*) -rps refsPerSen: number of reference translations per sentence\n       [[default: 1]]");
    println(" (*) -maxGL maxGramLength: maximum word gram length to collect statistics for\n       [[default: 4]]");
    println(" (*) -decOut decoderOutFile: name of the output file produced by your decoder\n       [[default: output.nbest]]");
    println(" (*) -decExit validExit: value returned by decoder to indicate success\n       [[default: 0]]");
    println(" (*) -p paramsFile: file containing parameter names, initial values, and ranges\n       [[default: params.txt]]");
    println(" (*) -rand randInits: initialize parameters randomly (1) or from paramsFile (0)\n       [[default: 0]]");
    println(" (*) -runs runCount: number of restarts; if > 1, randInits must be set to 1\n       [[default: 1]]");
    println(" (X) -seed firstSeed: first seed used for random number generation\n       [[default: time; please see documentation on how to use this parameter]]");
    println(" (*) -dcfg decConfigFile: name of decoder config file\n       [[default: config_file.txt]]");
    println(" (*) -save saveInterCfg: save intermediate config files (1) or not (0)\n       [[default: 0]]");
    println(" (*) -cmd commandFile: name of file containing command to run the decoder\n       [[default: decoder_command.txt]]");
    println(" (*) -N N: size of N-best list (per sentence) generated in each MERT iteration\n       [[default: 100]]");
    println(" (*) -reset resetCandList: reset candidate list every iteration (1) or not (0)\n       [[default: 0]]");
    println(" (*) -maxIt maxMERTIts: maximum number of MERT iterations\n       [[default: 10]]");
    println(" (*) -opi onePerIt: modify a single parameter per iteration (1) or not (0)\n       [[default: 0]]");
    println(" (*) -m metricName: name of the evaluation metric optimized by MERT\n       [[default: BLEU]]");
    println(" (*) -fin finalLambdas: file name for final lambda[] values\n       [[default: final_lambdas.txt]]");
    println(" (*) -v verbosity: output verbosity level (0-4; higher value => more verbose)\n       [[default: 1]]");
    println(" (*) -decV decVerbosity: should decoder output be printed (1) or ignored (0)\n       [[default: 0]]");
    println("");
    println("Ex.: java MERT MERT_config.txt");
    println("             OR:");
    println("     java MERT -s DEV07_es.txt -r DEV07_en.txt -rps 4 -init initFile.txt -N 500 -maxIt 50 -v 0");
  }

  private static String[] cfgFileToArgsArray(String fileName) throws Exception
  {
    checkFile(fileName);

    Vector argsVector = new Vector();


    BufferedReader inFile = new BufferedReader(new FileReader(fileName));

    String line, origLine;
    do {
      line = inFile.readLine();
      origLine = line; // for error reporting purposes

      if (line != null && line.length() > 0 && line.charAt(0) != '#') {

        if (line.indexOf("#") != -1) { // discard comment
          line = line.substring(0,line.indexOf("#"));
        }

        line = line.trim();

        // now line should look like "-xxx XXX"

        String[] paramA = line.split("\\s+");

        if (paramA.length == 2 && paramA[0].charAt(0) == '-') {
          argsVector.add(paramA[0]);
          argsVector.add(paramA[1]);
        } else {
          println("Malformed line in config file:");
          println(origLine);
          System.exit(70);
        }

      }
    }  while (line != null);

    inFile.close();


	String[] argsArray = new String[argsVector.size()];

    for (int i = 0; i < argsVector.size(); ++i) {
      argsArray[i] = (String)(argsVector.elementAt(i));
    }

    return argsArray;
  }

  private static void processArgsArray(String[] args) throws Exception
  {
    // set default values
    dirPrefix = null;
    sourceFileName = "source.txt";
    refFileName = "reference.txt";
    refsPerSen = 1;
    maxGramLength = 4;
    decoderOutFileName = "output.nbest";
    validDecoderExitValue = 0;
    paramsFileName = "params.txt";
    randInits = false;
    runCount = 1;
    finalLambdasFileName = "final_lambdas.txt";
    decoderCommandFileName = "decoder_command.txt";
    decoderConfigFileName = "config.txt";
    metricName = "BLEU";
    sizeOfNBest = 100;
    saveInterCfg = false;
    resetCandList = false;
    maxMERTIterations = 10;
    oneParamPerIteration = false;
    verbosity = 1;
    decVerbosity = 0;

    int i = 0;

    while (i < args.length) {
      String option = args[i];
      if (option.equals("-s")) { sourceFileName = args[i+1]; }
      else if (option.equals("-r")) { refFileName = args[i+1]; }
      else if (option.equals("-rps")) {
        refsPerSen = Integer.parseInt(args[i+1]);
        if (refsPerSen < 1) { println("refsPerSen must be positive."); System.exit(10); }
      }
      else if (option.equals("-maxGL")) {
        maxGramLength = Integer.parseInt(args[i+1]);
        if (maxGramLength < 1) { println("maxGramLength must be positive."); System.exit(10); }
      }
      else if (option.equals("-decOut")) { decoderOutFileName = args[i+1]; }
      else if (option.equals("-decExit")) {
        validDecoderExitValue = Integer.parseInt(args[i+1]);
      }
      else if (option.equals("-dir")) { dirPrefix = args[i+1]; }
      else if (option.equals("-p")) { paramsFileName = args[i+1]; }
      else if (option.equals("-rand")) {
        int rand = Integer.parseInt(args[i+1]);
        if (rand == 1) randInits = true;
        else if (rand == 0) randInits = false;
        else { println("randInits must be either 0 or 1."); System.exit(10); }
      }
      else if (option.equals("-runs")) {
        runCount = Integer.parseInt(args[i+1]);
        if (runCount < 1) { println("runCount must be positive."); System.exit(10); }
      }
      else if (option.equals("-fin")) { finalLambdasFileName = args[i+1]; }
      else if (option.equals("-cmd")) { decoderCommandFileName = args[i+1]; }
      else if (option.equals("-dcfg")) { decoderConfigFileName = args[i+1]; }
      else if (option.equals("-save")) {
        int save = Integer.parseInt(args[i+1]);
        if (save == 1) saveInterCfg = true;
        else if (save == 0) saveInterCfg = false;
        else { println("saveInterCfg must be either 0 or 1."); System.exit(10); }
      }
      else if (option.equals("-m")) {
        metricName = args[i+1];
        if (!EvaluationMetric.knownMetricName(metricName)) { println("Unknown metric name " + metricName + "."); System.exit(10); }
      }
      else if (option.equals("-N")) {
        sizeOfNBest = Integer.parseInt(args[i+1]);
        if (sizeOfNBest < 1) { println("N must be positive."); System.exit(10); }
      }
      else if (option.equals("-reset")) {
        int reset = Integer.parseInt(args[i+1]);
        if (reset == 1) resetCandList = true;
        else if (reset == 0) resetCandList = false;
        else { println("resetCandList must be either 0 or 1."); System.exit(10); }
      }
      else if (option.equals("-maxIt")) {
        maxMERTIterations = Integer.parseInt(args[i+1]);
        if (maxMERTIterations < 1) { println("maxMERTIts must be positive."); System.exit(10); }
      }
      else if (option.equals("-opi")) {
        int opi = Integer.parseInt(args[i+1]);
        if (opi == 1) oneParamPerIteration = true;
        else if (opi == 0) oneParamPerIteration = false;
        else { println("onePerIt must be either 0 or 1."); System.exit(10); }
      }
      else if (option.equals("-v")) {
        verbosity = Integer.parseInt(args[i+1]);
        if (verbosity < 0 || verbosity > 4) { println("verbosity should be between 0 and 4"); System.exit(10); }
      }
      else if (option.equals("-decV")) {
        decVerbosity = Integer.parseInt(args[i+1]);
        if (decVerbosity < 0 || decVerbosity > 1) { println("decVerbosity should be either 0 or 1"); System.exit(10); }
      }
      else {
        println("Unknown option " + option); System.exit(10);
      }

      i += 2;

    } // while (i)

    if (runCount > 1 && randInits == false) { println("For runCount > 1, randInits must be set to 1."); System.exit(10); }

    if (dirPrefix != null) {
      sourceFileName = fullPath(dirPrefix,sourceFileName);
      refFileName = fullPath(dirPrefix,refFileName);
      decoderOutFileName = fullPath(dirPrefix,decoderOutFileName);
      paramsFileName = fullPath(dirPrefix,paramsFileName);
      finalLambdasFileName = fullPath(dirPrefix,finalLambdasFileName);
      decoderCommandFileName = fullPath(dirPrefix,decoderCommandFileName);
      decoderConfigFileName = fullPath(dirPrefix,decoderConfigFileName);
    }

    if (refsPerSen > 1) {
      // the provided refFileName might be a prefix
      File dummy = new File(refFileName);
      if (!dummy.exists()) {
        refFileName = createUnifiedRefFile(refFileName,refsPerSen);
      }
    }

    checkFile(sourceFileName);
    checkFile(paramsFileName);
    checkFile(decoderCommandFileName);
    checkFile(decoderConfigFileName);



    println("Processed the following args array:",1);
    print("  ",1);
    for (i = 0; i < args.length; ++i) {
      print(args[i] + " ",1);
    }
    println("",1);
    println("",1);

  } // processArgs(String[] args)

  private static void checkFile(String fileName)
  {
    if (!fileExists(fileName)) {
      println("The file " + fileName + " was not found!");
      System.exit(40);
    }
  }

  private static boolean fileExists(String fileName)
  {
    File checker = new File(fileName);
    return checker.exists();
  }

  private static String createUnifiedRefFile(String prefix, int numFiles) throws Exception
  {
    if (numFiles < 2) {
      println("Warning: createUnifiedRefFile called with numFiles = " + numFiles + "; doing nothing.");
      return prefix;
    } else {
      File checker;
      checker = new File(prefix+"1");

      if (!checker.exists()) {
        checker = new File(prefix+".1");
        if (!checker.exists()) {
          println("Can't find reference files.");
          System.exit(50);
        } else {
          prefix = prefix + ".";
        }
      }

      String outFileName;
      if (prefix.endsWith(".")) { outFileName = prefix+"all"; }
      else { outFileName = prefix+".all"; }

      PrintWriter outFile = new PrintWriter(outFileName);

      BufferedReader[] inFile = new BufferedReader[numFiles];

      int nextIndex;
      checker = new File(prefix+"0");
      if (checker.exists()) { nextIndex = 0; }
      else { nextIndex = 1; }
      int lineCount = countLines(prefix+nextIndex);

      for (int r = 0; r < numFiles; ++r) {
        if (countLines(prefix+nextIndex) != lineCount) {
          println("Line count mismatch in " + (prefix+nextIndex) + ".");
          System.exit(60);
        }
        inFile[r] = new BufferedReader(new FileReader(prefix+nextIndex));
        ++nextIndex;
      }

      String line;

      for (int i = 0; i < lineCount; ++i) {
        for (int r = 0; r < numFiles; ++r) {
          line = inFile[r].readLine();
          outFile.println(line);
        }
      }

      outFile.close();

      for (int r = 0; r < numFiles; ++r) { inFile[r].close(); }

      return outFileName;

    }

  } // createUnifiedRefFile(String prefix, int numFiles)

  private static int countLines(String fileName) throws Exception
  {
    BufferedReader inFile = new BufferedReader(new FileReader(fileName));

    String line;
    int count = 0;
    do {
      line = inFile.readLine();
      if (line != null) ++count;
    }  while (line != null);

    inFile.close();

    return count;
  }

  private static int countWords(String fileName) throws Exception
  {
    Scanner inFile = new Scanner(new FileReader(fileName));

    String word;
    int count = 0;
    while (inFile.hasNext()) {
      word = inFile.next();
      ++count;
    }

    inFile.close();

    return count;
  }

  private static double quantize(double x, double precision)
  {
    // returns the value y closes to x for which y/precision is an integer
    // (if precision is 0.0, no quantization takes place and x is returned)

    if (precision == 0.0 || x == 0.0) return x;

// This acts funny because of precision issues:
//    double c1 = ((Math.floor(x/precision))*precision);
//    double c2 = c1 + precision;

// instead:
    BigDecimal div = new BigDecimal(Math.floor(x/precision));
    BigDecimal p_b = new BigDecimal(new Double(precision).toString()); // I know, so convoluted!
    BigDecimal c1_b = div.multiply(p_b);
    BigDecimal c2_b = c1_b.add(p_b);

    double c1 = c1_b.doubleValue();
    double c2 = c2_b.doubleValue();


    if (c1 == x) return x;

    // otherwise, c1 < x < c2
    // return the closer to x of c1,c2

    if (x - c1 < c2 - x) {
      return c1;
    } else if (x - c1 > c2 - x) {
      return c2;
    } else {
      // x is exactly between c1 and c2
      // return the further away from 0.0 of c1,c2
      if (Math.abs(c1) > Math.abs(c2)) return c1;
      else return c2;
    }

  }

  private static String fullPath(String dir, String fileName)
  {
    File dummyFile = new File(dir,fileName);
    return dummyFile.getAbsolutePath();
  }

  private static void println(Object obj, int priority) { if (priority <= verbosity) println(obj); }
  private static void print(Object obj, int priority) { if (priority <= verbosity) print(obj); }

  private static void println(Object obj) { System.out.println(obj); }
  private static void print(Object obj) { System.out.print(obj); }

  private static void showProgress()
  {
    ++progress;
    if (progress % 1000 == 0) print(".",1);
  }

}
